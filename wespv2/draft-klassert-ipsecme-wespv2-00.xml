<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- <xi:strict="yes" ?>
<xi:compact="yes" ?>
<xi:subcompact="no" ?>  -->
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" category="std" docName="draft-klassert-wespv2-00" ipr="trust200902" obsoletes="" updates="" submissionType="IETF" xml:lang="en" tocInclude="true" tocDepth="4" symRefs="true" sortRefs="true" version="3" consensus="true">
  <front>
    <!-- The abbreviated title is used in the page header - it is only necessary if the
        full title is longer than 39 characters -->
    <title abbrev="WESPv2">Wrapped ESP Version 2</title>
    <!-- add 'role="editor"' below for the editors if appropriate -->
    <!-- Another author who claims to be an editor -->
    <author fullname="Steffen Klassert" initials="S." surname="Klassert">
      <organization abbrev="secunet">secunet Security Networks AG</organization>
      <address>
        <email>steffen.klassert@secunet.com</email>
      </address>
    </author>
    <area>sec</area>
    <workgroup>IPSECME Working Group</workgroup>
    <keyword>IKEv2</keyword>
    <keyword>WESPv2</keyword>
    <abstract>
      <t>
      This document describes the Wrapped Encapsulating Security Payload v2
      (WESPv2) protocol, which builds on the Encapsulating Security Payload
      (ESP) RFC 4303. It is designed to overcome limitations of the ESP
      protocol to expose flow information to the network in a transparent way
      and to align the cipher text to the needs of the sender and receiver.
      To do so, it defines an optional Flow Identifyer where flow speciffic information
      can be stored. It also defines a Crypto Offset to allow intermediate
      devices to read some header bytes at the beginning of the inner packet.
      In particular, this preserves the original usecase of WESP <xref target="RFC5840"/>.
      Optional padding is added for cipher text alignment.
    </t>
    </abstract>
  </front>
  <middle>
    <section numbered="true" toc="default">
      <name>Introduction</name>
      <t>
      WESPv2 is a wrapper for the ESP protocol. Due to the absence of a version
      number in the ESP protocol, it can't be updated in a transparent way.
      Any updates to ESP must be negotiated by IKEv2 and for that, invisible to
      intermediate devices. In the recent past, several attempts were taken to
      introduce a Flow Identifyer for certain useceses. Examples are
      <xref target="I-D.ponchon-ipsecme-anti-replay-subspaces"/> and
      <xref target="I-D.he-ipsecme-vpn-shared-ipsecsa"/>. Additionally to that,
      there exists a specification oif the PSP [PSP (add reference!)] protocol
      that has the need of a Flow Identifyer. PSP also defines a Crypto Offset
      to expose parts of the headers of the inner packet. Showing headers
      on the inner packet was also the original usecase for the WESP protocol.
      WESPv2 provides a solution for all the aforementioned usecases.
      </t>
      <t>
      The 32 bit Flow Identifyer field introduced by WESPv2 is considered to
      be opaque to this document. Future documents can define the meaning
      of this field for their particular usecase. With his, all existing
      and potential new usecases for a Flow Identifyer can be covered.
      For instance it can be used for the case of
      <xref target="I-D.ponchon-ipsecme-anti-replay-subspaces"/>  or
      <xref target="I-D.he-ipsecme-vpn-shared-ipsecsa"/> etc., or combinations
      thereof if fit into the 32 bit field. A detailed discussion about
      the problems of the ESP protocol can be found in
      <xref target="I-D.mrossberg-ipsecme-multiple-sequence-counters"/>.
      </t>
      <section numbered="true" toc="default">
        <name>Requirements Language</name>
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
       "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
       document are to be interpreted as described in
			 <xref target="RFC2119" format="default">RFC 2119</xref>.</t>
      </section>

      <!--
      <section numbered="true" toc="default">
        <name>Terminology</name>
        <t>
       In this section we define the terms specific to this document.  This
   section is normative.
	</t>
        <ul>
          <li>
	Terminology ...
	</li>
          <li>
	Terminology ...
	</li>
        </ul>
      </section>
      -->
    </section>

    <section anchor="Protocol-definition" numbered="true" toc="default">
      <name>Protocol Definition</name>
      <t>
   In this section we define the exact protocol formats and operations. This section is normative.
   </t>


      <section anchor="WESPv2-header-format" numbered="true" toc="default">
        <name>WESPv2 header format</name>
        <t>
	The WESPv2 header is split into a 4 byte base header that
	is always present and an optional part directly following
	the base header. The base header essentially describes how
	to treat the packet. The optional part of the header ensure
	proper alignment of the ESP cipher text. It also
	has an option to store an integrity protected flow identifyter
	that can be used for flow classification.
   </t>
    <t>
	The header is constructed in a way that the start
	of the ciphertext is aligned on a 16 byte boundary respective
	the start of the IPv4/IPv6 header. Any IPv4 options and optional
	IPv6 extension Headers are not taken into account here.
	Like WESPv1,
	this extension essentially acts as a wrapper to the existing ESP
        protocol. The value of the new protocol version used to identify
	this new header is not changed. Instead, the version number
	in the Flags field is incremented to identify this new protocol
	version. Further details are shown below:

   </t>
   <t>
   FIXME: Remove this block before publishing.
   -----------------------------------------------------------------
       IPv4:
	   NET_IP_ALIGN(2) + ethernet_header(14) + IP_header(20) + wesp_base_header(4)
	   + padding(8) + FID(8) + ESP(8)
   </t>
   <t>
        IPv6:
	   NET_IP_ALIGN(2) + ethernet_header(14) + IP_header(40) + wesp_base_header(4)
	   + padding(4) + FID(8) + ESP(8)
   -----------------------------------------------------------------
   </t>

        <figure align="center" anchor="wespv2-header">
          <name> WESPv2  header format </name>
          <artwork align="left"><![CDATA[


    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Next Header  |    Hdr Len    |CryptOffset| R |     Flags     |
   +---------------+---------------+-------------------------------+
   |                        Padding (optional)                     |
   +---------------------------------------------------------------+
   |                         FID (optional)                        |
   |                                                               |
   +---------------------------------------------------------------+
   |                   Existing ESP Encapsulation                  |
   ~                                                               ~
   |                                                               |
   +---------------------------------------------------------------+
	]]></artwork>
        </figure>
        <ul>
          <li>
		Next Header - 8 bits: This field MUST be the same as the Next Header
		field in the ESP trailer whenever the CryptOffset field is nonzero.
		If the CryptOffset field is zero, the Next Header MUST be set 
		to zero too.
		The receiver MUST do
		some sanity checks before the WESPv2 packet is accepted.  The receiver
		MUST ensure that the Next Header field in the WESPv2 header and the
		Next Header field in the ESP trailer match whenever the Next Header field
		is nonzero.  The packet MUST be dropped if the two do not
		match.  Similarly, the receiver MUST ensure that the Next Header
		field in the WESPv2 header is an empty field initialized to zero if
		the CryptOffset field is zero.
		</li>
          <li>
		HdrLen - 8 bits: Offset from the beginning of the WESPv2 header to the
		beginning of the Rest of Payload Data (i.e., past the IV, if present
		and any other WESPv2 options defined in the future) within the
		encapsulated ESP header, in octets. The following HdrLen values are
		invalid: any value less than 12; any value that is not a multiple
		of 4; any value that is not a multiple of 8 when using IPv6. The
		receiver MUST ensure that this field matches with the header offset
		computed from using the negotiated Security Association (SA) and MUST
		drop the packet in case it does not match.
		</li>
          <li>
		CryptOffset - 6 bits: The offset from the end of the IV to the start
		of the encrypted portion of the packet, mesured in 4 octet units.
		The resulting value MUST NOT be larger than the size of the inner
		packet. A zero CryptOffset means that the complete packet is
		authenticated and encrypted. A positive CryptOffset means that
		the first 'CryptOffset * 4' octets of the inner packet belong
		to the AAD but are not encrypted. In this case the Next Header
		field MUST be the same as the Next Header field in the ESP trailer,
		so that the Header can be parsed by intermideate devices.
		</li>
          <li>
		Reserved - 2 bits: Set to zero on transmit, ignored on receive.
		</li>
          <li>
		Flags - 8 bits: The bits are defined most-significant-bit (MSB) first,
		so bit 0 is the most significant bit of the flags octet.
		</li>
        </ul>
        <figure align="center" anchor="Flags-Format">
          <name> Flags Format </name>
          <artwork align="center"><![CDATA[


       0 1 2 3 4 5 6 7
      +-+-+-+-+-+-+-+-+
      |V V|E|P|F|  R  |
      +-+-+-+-+-+-+-+-+
	]]></artwork>
        </figure>
        <ul>
          <li>
		Version (V) - 2 bits: MUST be sent to 1 and checked by the receiver.
		If the version is different than an expected version number (e.g.,
		negotiated via the control channel), then the packet MUST be dropped
		by the receiver.  Future modifications to the WESPv2 header require a
		new version number.  In particular, the version of WESPv2 defined in
		this document does not allow for any extensions.  However, old
		implementations will still be able to find the encapsulated cleartext
		packet using the HdrLen field from the WESPv2 header, when the 'E' bit
		is not set.  Intermediate nodes dealing with unknown versions are not
		necessarily able to parse the packet correctly.  Intermediate
		treatment of such packets is policy dependent (e.g., it may dictate
		dropping such packets).
		</li>
          <li>
		Encrypted Payload (E) - 1 bit: Has no meaning in WESPv2 as the
		CryptOffset declares which parts of the payload is protected with
		encryption. (FIXME: should it be set to 1 to align with WESPv1?)
		</li>
          <li>
		Padding header (P) - 1 bit: If set (value 1), the padding is
		present.  If not set (value 0), the padding is absent.

		[FIXME: "If WESPv2 is being used with UDP encapsulation (see Section
		2.1 below) and IPv6, the Protocol Identifier (0x00000002) occupies 4
		octets so the IPv6 padding is not needed, as the header is already on
		an 8-octet boundary.  This padding MUST NOT be used with IPv4, as it
		is not needed to guarantee 4-octet IPv4 alignment."]
		</li>
          <li>
		FID (F) - 1 bit: If set (value 1), the FID is
		present behind the WESPv2 trader.  If not set (value 0),
		the FID is absent.
		</li>
          <li>
		R - 4 bits: Reserved for future versions, MUST be set to 0,
		and ignored by the receiver.
		</li>
          <li>
		Padding - optional: Used to ensure proper alignment of the
		following fields.
		If padding is present, the padding must
		be chosen in a way that the ICV (if present) and the IV is aligned
		on a minimum of 16 bytes for IPv4 and on a minimum of 32 bytes on IPv6.
          </li>
          <li>
		Flow Identifyer (FID) - optional: Authenticated field with
		additional flow informations. The meaning of this field can be
		negotiated by IKEv2. The definition of this field is out
		of scope for this document.
		(Sub-Child SAs could be encoded here, for
		example.) If present, MUST be 8 byte if the ESP header carries
		only the lower 32 bit of the sequence number. It MUST be 4 byte
		if the full 64 bit sequence number is transmitted in the ESP header.
		The choice of the size is to ensure proper alignment of the
		following fields. [FIXME: Maybe just 4 byte and integrate into
		the IV by xor with the noonce ('unique IV' if used for seq subspaces)]
		</li>
        </ul>
        <t>
   Some text here...
   </t>
      </section>


      <section anchor="Packet-format" numbered="true" toc="default">
        <name>Packet format</name>
        <t>
	The following section defines the resulting packet format.
	Tunnel and Transport Modes are handled exactly the same way as in
	WESP <xref target="RFC5840"/>. The WESPv2 headers are inserted between the
	outer IPv4/IPv6 header and the ESP header. The WESPv2 header
	MUST be inserted before the cryptographic operations.
	After inserting the WESPv2 header, the crypto operations
	are performed. The optional Flow Identifyer (FID) MUST
	be included into the integrity prtoected part of the packet,
	if present.
   </t>
      </section>
      <section anchor="IPv4" numbered="true" toc="default">
        <name>IPv4 Datagram</name>
        <figure anchor="ipv4before" align="center">
          <name>IPv4 DATAGRAM BEFORE APPLYING WESP</name>
          <artwork align="left"><![CDATA[
            -----------------------------------------------
            | outer IP hdr  | ESP | ESP Payload |   ESP   |
            | (any options) | Hdr |    Data     | Trailer |
            -----------------------------------------------
		     ]]></artwork>
        </figure>
        <figure align="center" anchor="ipv4after">
          <name> IPv4 DATAGRAM AFTER APPLYING WESP </name>
          <artwork align="left"><![CDATA[
                      |<- WESPv2 Hdr ->|
        -----------------------------------------------------
        |outer IP hdr |WESP| PAD | FID |ESP|Pyld|  ESP  |ICV|
        |(any options)|BHdr|(opt)|(opt)|Hdr|Data|Trailer|   |
        -----------------------------------------------------
                                       |<- encryption ->|
                                 |<---- integrity ----->|

				]]></artwork>
        </figure>
      </section>
      <section anchor="IPv6" numbered="true" toc="default">
        <name>IPv6 Datagram</name>
        <figure anchor="ipv6before" align="center">
          <name>IPv6 DATAGRAM BEFORE APPLYING WESP</name>
          <artwork align="left"><![CDATA[
            -------------------------------------------------
            |  outer   | ext. | ESP | ESP Payload |   ESP   |
            | IPv6 Hdr | Hdrs | Hdr |    Data     | Trailer |
            -------------------------------------------------
		     ]]></artwork>
        </figure>
        <figure align="center" anchor="ipv6after">
          <name> IPv6 DATAGRAM AFTER APPLYING WESP </name>
          <artwork align="left"><![CDATA[
                      |<- WESPv2 Hdr ->|
        -----------------------------------------------------
        |  outer |ext.|WESP| PAD | FID |ESP|Pyld|  ESP  |ICV|
        |IPv6 Hdr|Hdrs|BHdr|(opt)|(opt)|Hdr|Data|Trailer|   |
        -----------------------------------------------------
                                       |<- encryption ->|
                                 |<---- integrity ----->|

				]]></artwork>
        </figure>
      </section>
    </section>

    <section anchor="IKENegotiation" numbered="true" toc="default">
      <name>IKEv2 Negotiation</name>
      <t>
	The IKEv2 negotiation follows exatcly the way it is done in
	WESP <xref target="RFC5840"/>, with the difference that a new notification
	USE_WESPv2_MODE is used.
	</t>
	<t>
	The following text is from WESP <xref target="RFC5840"/> and adjusted to
	match the WESPv2 version.
	</t>
      <t>
	This document assumes that WESPv2 negotiation is performed using IKEv2.
	In order to negotiate the new format of ESP encapsulation via IKEv2
	<xref target="RFC7296"/>, both parties need to agree to use the new packet format.
	This can be achieved using a notification method similar to
	USE_TRANSPORT_MODE, defined in <xref target="RFC7296"/>.
</t>
<t>

	The notification, USE_WESPv2_MODE (value TBD) MUST be included in a
	request message that also includes an SA payload requesting a
	CHILD_SA using ESP.  It signals that the sender supports the WESPv2
	version defined in the current document and requests that the
	CHILD_SA use WESPv2 mode rather than ESP for the SA created.  If the
	request is accepted, the response MUST also include a notification of
	type USE_WESP_MODE.  If the responder declines the request, the
	CHILD_SA will be established using ESP, as per <xref target="RFC7296"/>. 
	If this is unacceptable to the initiator, the initiator MUST delete the SA.
</t>
<t>

	Note: Except when using the options to negotiate WESPv1 or WESPv2 mode,
	all CHILD_SAs will use standard ESP.
</t>
<t>

	Negotiation of WESPv2 in this manner preserves all other negotiation
	parameters, including NAT-T <xref target="RFC3948"/>.  NAT-T is wholly
	compatible with this wrapped format and can be used as-is, without any
	modifications, in environments where NAT is present and needs to be
	taken into account.
</t>
<t>

	WESPv2 version negotiation is not introduced as part of this
	specification.  If the WESP version is updated in a future
	specification, then that document MUST specify how the WESP version
	is negotiated.
	 </t>
    </section>
    <section anchor="IANA" title="IANA Considerations">
      <t>
        This document defines a new IKEv2 Notify Message Type payloads for the IANA "IKEv2 Notify Message Types - Status Types" registry.
        </t>
      <figure align="center" anchor="iana_requests_i">
        <artwork align="left"><![CDATA[
      Value   Notify Type Messages - Status Types    Reference
      -----   ------------------------------    ---------------
      [TBD1]   USE_WESPv2_MODE                      [this document]
            ]]></artwork>
      </figure>
    </section>
    <section anchor="Implementation" numbered="true" toc="default">
      <name>Implementation Status</name>
      <t>
	 [Note to RFC Editor: Please remove this section and the reference to
      <xref target="RFC6982"/> before publication.]
	    </t>
      <t>
      This section records the status of known implementations of the
      protocol defined by this specification at the time of posting of
      this Internet-Draft, and is based on a proposal described in
      <xref target="RFC7942"/>. The description of implementations in this
      section is intended to assist the IETF in its decision processes
      in progressing drafts to RFCs. Please note that the listing of
      any individual implementation here does not imply endorsement
      by the IETF. Furthermore, no effort has been spent to verify the
      information presented here that was supplied by IETF contributors.
      This is not intended as, and must not be construed to be, a catalog
      of available implementations or their features. Readers are advised
      to note that other implementations may exist.
     </t>
      <t>
      According to <xref target="RFC7942"/>, "this will allow reviewers
      and working groups to assign due consideration to documents that
      have the benefit of running code, which may serve as evidence of
      valuable experimentation and feedback that have made the implemented
      protocols more mature.  It is up to the individual working groups
      to use this information as they see fit".
     </t>
      <t>
      Authors are requested to add a note to the RFC Editor at the
      top of this section, advising the Editor to remove the entire
      section before publication, as well as the reference to <xref target="RFC7942"/>.
     </t>
      <section anchor="impl-status.Linux.xfrm" title="Linux XFRM">
        <t> Linux </t>
        <dl>
          <dt> Organization: </dt>
          <dd> Linux kernel Project</dd>
          <dt> Name: </dt>
          <dd> Linux Kernel  https://www.kernel.org/</dd>
          <dt> Description: </dt>
          <dd> Not implemented </dd>
          <dt> Level of maturity: </dt>
          <dd> None</dd>
          <dt> Licensing: </dt>
          <dd> GPLv2</dd>
          <dt> Implementation experience: </dt>
          <dd> TBD</dd>
          <dt> Contact: </dt>
          <dd> https://lore.kernel.org/netdev/ </dd>
        </dl>
      </section>
      <section anchor="section.impl-status.strongswan" title="strongSwan">
        <dl>
          <dt> Organization: </dt>
          <dd> The strongSwan Project</dd>
          <dt> Name: </dt>
          <dd> strongSwan https://docs.strongswan.org/docs/5.9/swanctl/swanctlConf.html </dd>
          <dt> Description: </dt>
          <dd> Not implemented</dd>
          <dt> Level of maturity: </dt>
          <dd> None</dd>
          <dt> Coverage: </dt>
          <dd> TBD </dd>
          <dt> Licensing: </dt>
          <dd> GPLv2</dd>
          <dt> Implementation experience </dt>
          <dd>	TBD</dd>
          <dt> Contact </dt>
          <dd>TBD</dd>
        </dl>
      </section>
    </section>
    <section anchor="Security" numbered="true" toc="default">
      <name>Security Considerations</name>
      <t>
      In this section we discuss the security properties of WESPv2: TBD
	</t>
      <t>
      Some text ...
   </t>
    </section>
    <section anchor="Acknowledgements" numbered="true" toc="default">
      <name>Acknowledgments</name>
      <t> TBD </t>
    </section>
  </middle>
  <back>
    <references>
      <name>Normative References</name>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3948.xml"/>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4301.xml"/>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4303.xml"/>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5840.xml"/>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7296.xml"/>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.791.xml"/>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8200.xml"/>
    </references>
    <references>
      <name>Informative References</name>
      <xi:include href="https://bib.ietf.org/public/rfc/bibxml3/reference.I-D.pwouters-ipsecme-multi-sa-performance.xml"/>
      <xi:include href="https://bib.ietf.org/public/rfc/bibxml3/reference.I-D.mrossberg-ipsecme-multiple-sequence-counters.xml"/>
      <xi:include href="https://bib.ietf.org/public/rfc/bibxml3/reference.I-D.ponchon-ipsecme-anti-replay-subspaces.xml"/>
      <xi:include href="https://bib.ietf.org/public/rfc/bibxml3/reference.I-D.he-ipsecme-vpn-shared-ipsecsa.xml"/>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3552.xml"/>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6982.xml"/>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7942.xml"/>

<!--
    <reference anchor="PSP" target="https://github.com/google/psp/blob/main/doc/PSP_Arch_Spec.pdf">
    <front>
    <title>PSP Architecture Specification</title>
    </front>
    </reference>
-->
    </references>
    <section anchor="app-additional" numbered="true" toc="default">
      <name>Additional Stuff</name>
      <t>This becomes an Appendix.</t>
    </section>
  </back>
</rfc>
