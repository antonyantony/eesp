<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- <xi:strict="yes" ?>
<xi:compact="yes" ?>
<xi:subcompact="no" ?>  -->
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" category="std"
docName="draft-klassert-ipsecme-wespv2-00" ipr="trust200902" obsoletes="" updates=""
submissionType="IETF" xml:lang="en" tocInclude="true" tocDepth="4"
symRefs="true" sortRefs="true" version="3" consensus="true">
  <front>
    <!-- The abbreviated title is used in the page header - it is only necessary if the
        full title is longer than 39 characters -->
    <title abbrev="WESPv2">Wrapped ESP Version 2</title>
    <!-- add 'role="editor"' below for the editors if appropriate -->
    <!-- Another author who claims to be an editor -->
    <author fullname="Steffen Klassert" initials="S." surname="Klassert">
      <organization abbrev="secunet">secunet Security Networks AG</organization>
      <address>
        <email>steffen.klassert@secunet.com</email>
      </address>
    </author>
    <author initials="A." surname="Antony" fullname="Antony Antony">
      <organization abbrev="secunet">secunet Security Networks AG</organization>
      <address>
        <email>antony.antony@secunet.com</email>
      </address>
    </author>
    <area>sec</area>
    <workgroup>IPSECME Working Group</workgroup>
    <keyword>IKEv2</keyword>
    <keyword>WESPv2</keyword>
    <abstract>
      <t>This document describes the Wrapped Encapsulating Security Payload v2
      (WESPv2) protocol, which builds on the Encapsulating Security Payload
      (ESP)
      <xref target="RFC4303"/>. It is designed to overcome limitations of the
      ESP protocol to expose flow information to the network in a transparent
      way and to align the cipher text to the needs of the sender and receiver.
      To do so, it defines an optional Flow Identifier where flow specific
      information can be stored. It also defines a Crypt Offset to allow
      intermediate devices to read some header bytes at the beginning of the
      inner packet. In particular, this preserves the original use-case of WESP

      <xref target="RFC5840"/>. Optional padding can be added for cipher text
      alignment.</t>
    </abstract>
  </front>
  <middle>
    <section numbered="true" toc="default">
      <name>Introduction</name>
      <t>WESPv2 is a wrapper for the ESP protocol. Due to the absence of a
      version number in the ESP protocol, in the packet header, ESP can't be
      updated in a transparent way. Any updates to ESP must be negotiated by
      IKEv2 and for that, indiscernible to intermediate devices such as routers
      and firewalls. In the recent past, several attempts were taken to
      introduce a Flow Identifier for certain use-cases. Examples are
      <xref target="I-D.ponchon-ipsecme-anti-replay-subspaces"/> and
      <xref target="I-D.he-ipsecme-vpn-shared-ipsecsa"/>. Such a Flow
      Identifier could also be used to perform ECMP based on the inner flows at
      intermediate devices or endpoints. Additionally to that, there exists a
      specification of the
      <xref target="PSP"/> protocol that has the need of a Flow Identifier,
      called 
      Network Identifier (VNI) there. PSP also defines a Crypto Offset to expose
      parts of the headers of the inner packet. Showing headers on the inner
      packet was also the original usecase for the WESP protocol. WESPv2
      provides a solution for all the aforementioned use-cases.</t>
      <t>The 64 bit Flow Identifier field introduced by WESPv2 is considered to
      be opaque to this document. Future documents can define the meaning of
      this field for their particular use-case. With this, all existing and
      potential new use-cases for a Flow Identifier can be covered. For
      instance it can be used for the case of
      <xref target="I-D.ponchon-ipsecme-anti-replay-subspaces"/> or
      <xref target="I-D.he-ipsecme-vpn-shared-ipsecsa"/> etc., or combinations
      thereof if fit into the 64 bit field. A detailed discussion about the
      problems of the ESP protocol can be found in
      <xref target="I-D.mrossberg-ipsecme-multiple-sequence-counters"/>.</t>
      <t>Though this document specifies IKEv2 as a negotiation protocol, WESPv2
      may use other protocols for negotiation and key derivation. The packet
      specification is portable to other key protocol use cases, such as
      <xref target="PSP"/>, and offers versioning at the packet level.</t>
      <section numbered="true" toc="default">
        <name>Requirements Language</name>
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
        document are to be interpreted as described in
        <xref target="RFC2119" format="default">RFC 2119</xref>.</t>
      </section>
      <section numbered="true" toc="default">
        <name>Terminology</name>
        <t>This document uses the following terms defined in IKEv2
        <xref target="RFC7296"/>: Child SA, CREATE_CHILD_SA, IKE_AUTH
        exchange, USE_TRANSPORT_MODE</t>
        <t>This document uses the following terms defined in
        <xref target="PSP"/>: PSP (a recursive acronym for PSP Security
        Protocol), Network Identifier (VNI), Crypt Offset.</t>
        <t>This document uses the following terms defined in
        <xref target="RFC5840"/>: Wrapped Encapsulating Security Payload
        (WESP), USE_WESP_MODE.</t>
        <t>This document uses the following terms defined in
        <xref target="RFC2992"/>: Equal-cost multi-path (ECMP)</t>
        <t>This document uses the following terms defined in
        <xref target="RFC4303"/>: Encapsulating Security Payload (ESP).</t>
        <t>This document uses the following terms defined in
        <xref target="I-D.mrossberg-ipsecme-multiple-sequence-counters"/>:
        Sub-Child SA.</t>
      </section>
    </section>
    <section anchor="Protocol-definition" numbered="true" toc="default">
      <name>Protocol Definition</name>
      <t>In this section we define the exact protocol formats and operations.
      This section is normative.</t>
      <section anchor="WESPv2-header-format" numbered="true" toc="default">
        <name>WESPv2 header format</name>
        <t>The WESPv2 header is split into a 4 byte base header that is always
        present and an optional part directly following the base header. The
        base header essentially describes how to treat the packet. The optional
        part of the header ensure proper alignment of the ESP cipher text. It
        also has an option to store an integrity protected flow identifier
        that can be used for flow classification.</t>
        <t>The header is constructed in a way that the start of the cipher-text
        is aligned on a 8 byte boundary respective the start of the IPv4/IPv6
        header. Any IPv4 options and optional IPv6 extension Headers are not
        taken into account here. If the sender has different alignment
        requirements, optional padding can be used to align the cipher-text.
        The chosen padding size SHOULD NOT change for a given Child SA.
        (Authors note: Should the padding size be negotiated?) Like WESPv1,
        this extension essentially acts as a wrapper to the existing ESP
        protocol. The value of the new protocol version used to identify this
        new header is not changed. Instead, the version number in the Flags
        field is incremented to identify this new protocol version. Further
        details are shown below:</t>
        <!--
   <t>
   FIXME: Remove this block before publishing.
       IPv4:
           NET_IP_ALIGN(2) + ethernet_header(14) + IP_header(20) + wesp_base_header(4)
           + padding(8) + FID(8) + ESP(8)
   </t>
   <t>
        IPv6:
           NET_IP_ALIGN(2) + ethernet_header(14) + IP_header(40) + wesp_base_header(4)
           + padding(4) + FID(8) + ESP(8)
   </t>
   -->
        <figure align="center" anchor="wespv2-header">
          <name>WESPv2 header format</name>
          <artwork align="left">
            <![CDATA[


    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Next Header  |    HdrLen     |CryptOffset| R | V |  OptLen   |
   +---------------+---------------+-------------------------------+
   |                                                               |
   ~                             Options                           ~
   |                                                               |
   +---------------------------------------------------------------+
   |                   Existing ESP Encapsulation                  |
   ~                                                               ~
   |                                                               |
   +---------------------------------------------------------------+
        ]]>
</artwork>
        </figure>
        <ul>
          <li>Next Header - 8 bits: This field MUST be the same as the Next
          Header field in the ESP trailer whenever the Crypt Offset field is
          nonzero. If the Crypt Offset field is zero, the Next Header MUST be
          set to zero too. The receiver MUST do some sanity checks before the
          WESPv2 packet is accepted. The receiver MUST ensure that the Next
          Header field in the WESPv2 header and the Next Header field in the
          ESP trailer match whenever the Next Header field is nonzero. The
          packet MUST be dropped if the two do not match. Similarly, the
          receiver MUST ensure that the Next Header field in the WESPv2 header
          is an empty field initialized to zero if the Crypt Offset field is
          zero.</li>
          <li>HdrLen - 8 bits: Offset from the beginning of the WESPv2 header
          to the beginning of the Rest of Payload Data (i.e., past the IV, if
          present and any other WESPv2 options defined in the future) within
          the encapsulated ESP header, in octet. The following HdrLen values
          are invalid: any value less than 12; any value that is not a multiple
          of 4; any value that is not a multiple of 8 when using IPv6. The
          receiver MUST ensure that this field matches with the header offset
          computed from using the negotiated Security Association (SA) and MUST
          drop the packet in case it does not match.</li>
          <li>Crypt Offset - 6 bits: The offset from the end of the IV to the
          start of the encrypted portion of the packet, measured in 4 octet
          units. The resulting value MUST NOT be larger than the size of the
          inner packet. A zero CryptOffset means that the complete packet is
          authenticated and encrypted. A positive CryptOffset means that the
          first 'CryptOffset * 4' octets of the inner packet belong to the AAD
          but are not encrypted. In this case the Next Header field MUST be the
          same as the Next Header field in the ESP trailer, so that the Header
          can be parsed by intermediate devices. (Authors note: This is to
          preserve the original WESP use-case and because PSP uses this too. In
          case the Flow Identifier can carry enough information about inner
          flows, we can remove the cryptoffset.)</li>
          <li>Reserved - 2 bits: Set to zero on transmit, ignored on
          receive.</li>
          <li>Version (V) - 2 bits: MUST be sent to 1 and checked by the
          receiver. If the version is different than an expected version number
          (e.g., negotiated via the control channel), then the packet MUST be
          dropped by the receiver. Future modifications to the WESPv2 header
          require a new version number. In particular, the version of WESPv2
          defined in this document does not allow for any extensions. However,
          old implementations will still be able to find the encapsulated
          clear-text packet using the HdrLen field from the WESPv2 header, when
          the 'E' bit is not set. Intermediate nodes dealing with unknown
          versions are not necessarily able to parse the packet correctly.
          Intermediate treatment of such packets is policy dependent (e.g., it
          may dictate dropping such packets).</li>
          <li>OptLen - 6 bit: Total lenght of all options included in the WESPv2
	  header, in octets.
          </li>
          <li>Options - variable: Authenticated field with
          additional flow informations and padding. 
          </li>
        </ul>
        <!--
        <t>
   Some text here...
   </t>
   -->
      </section>

      <section anchor="Options" numbered="true" toc="default">
        <name>Options</name>
	<t>WESPv2 options carry a variable number of "options" that are
	type-length- value (TLV) encoded in the same format as done in
	<xref target="RFC8200"/> Section 4.2 for IPv6 extension headers.
	This document defines three different option classes, Padding Options,
	Flow Identifier Options and Private Options.</t>
	<t>Padding Options MUST be used to align the start of the next
	header to the natural alignment of the protocol, i.e. 4 byte for IPv4
	and 8 byte for IPv6. Other padding, like padding for cipher text alignment,
	is out of the scope of this document. Future documents can define this
	by using the existing padding options. Additional padding MUST be
	negotiated by IKEv2 or any other suitable protocol.</t>

	<t>
	Flow Identifier Options MUST carry characteristic information of the inner flow, i.e.
	MUST NOT change on per packet basis. It MUST be negotiated by
	IKEv2 or any other suitable protocol.

	The detailed specification of
	Flow Identifiers MUST be provided in subsequent documents. These Options are
	opaque to intermediate devices; however, intermediate routers MAY use
	it for identifying flows for ECMP or similar purposes. e.g. Sub-Child
	SAs, in <xref target="I-D.mrossberg-ipsecme-multiple-sequence-counters"/>could
	be encoded here. Flow Identifiers MUST have the format of Options
	as defind in <xref target="Adapt-Options"/>.
	</t>

	<t>Private Options comming from a reserved Option Type Range and
	can be used for any purposes that are out of scope for standardization.
	For example it can be used to encode hardware specific information,
	such as used encryption/authentication algorithms as done in <xref target="PSP"/>.</t>

	<t>The only WESPv2 Option Types defined in this document are the Pad1 and
	   PadN options specified in <xref target="Adapt-Options"/>.</t>

  <section title=" Adapting IPv6 Extension header options" anchor="Adapt-Options">

	<t>WESPv2 extension header Options are adapted from IPv6 extension header Options as
	   defined in Section 4.2 of <xref target="RFC8200"/>, with the following modifications:</t>

	<ul>
	<li>References to the IPv6 header are removed. </li>
	<li>The two highest-order bits of the Option Type MUST be set to 00, if the Option
	Type comes from the private range. </li>
	<li>The third-highest-order bit of the Option Type MUST be set to 0. </li>
	<li>References to the Hop-by-Hop
	   Options header and the Destination Options header are removed.</li>
	</ul>

	</section>

  <section title=" WESPv2 Extension header options" anchor="WESPv2-Options">

    <t>WESPv2 Options
     carry a variable number of type-length-value (TLV) encoded
    "options", of the following format:</t>

    <figure><artwork align="left"><![CDATA[
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - - -
   |  Option Type  |  Opt Data Len |  Option Data
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - - -
   ]]></artwork></figure>

	<ul>
	<li> Option Type: 8-bit identifier of the type of option.</li>
      <li> Opt Data Len: 8-bit unsigned integer.  Length of
      the Option Data field of this option, in octets.</li>
      <li> Option Data: Variable-length field. Option-Type-specific data.</li>
	</ul>

    <t>The sequence of options within a header must be processed
    strictly in the order they appear in the header; a receiver must
    not, for example, scan through the header looking for a particular
    kind of option and process that option prior to processing all
    preceding ones.</t>

    <t>The Option Type identifiers are internally encoded such that
    their highest-order two bits specify the action that must be taken
    if the processing node does not recognize the Option Type:</t>

	<ul>
	<li> 00 - skip over this option and continue processing
      the header.</li>
      <li> 01 - discard the packet.</li>
      <li> 10 - discard the packet and, regardless of whether
      or not the packet's Destination Address was a multicast address,
      send an ICMP Parameter Problem, Code 2, message to the packet's
      Source Address, pointing to the unrecognized Option Type.</li>
      <li> 11 - discard the packet and, only if the packet's
      Destination Address was not a multicast address, send an ICMP
      Parameter Problem, Code 2, message to the packet's Source
      Address, pointing to the unrecognized Option Type.</li>
	</ul>

	<t>Option from the private range MUST set the two
	highest-order bit to 00.</t>

    <t>The third-highest-order bit of the Option Type specifies
    whether or not the Option Data of that option can change en-route
    to the packet's final destination. That bit is left in to be
    compliant with IPv6 extenstion header options. WESPv2
    options are authenticated, therefore this bit MUST be set to 0.
    </t>

	<ul>
	<li>0 - Option Data does not change en-route</li>
      <li>1 - Option Data may change en-route</li>
	</ul>

    <t>The three high-order bits described above are to be treated as
    part of the Option Type, not independent of the Option Type.  That
    is, a particular option is identified by a full 8-bit Option Type,
    not just the low-order 5 bits of an Option Type.</t>

    <t>Individual options may have specific alignment requirements, to
    ensure that multi-octet values within Option Data fields fall on
    natural boundaries.  The alignment requirement of an option is
    specified using the notation xn+y, meaning the Option Type must
    appear at an integer multiple of x octets from the start of the
    header, plus y octets.  For example:</t>

      <?rfc subcompact="yes" ?>
      <ul>
      <li>2n means any 2-octet offset from the start of the header.</li>
      <li>8n+2 means any 8-octet offset from the start of the header,
      plus 2 octets.</li>
	</ul>

    <?rfc subcompact="no" ?>

    <t>There are two padding options which are used when necessary to
    align subsequent options and to pad out the containing header to a
    multiple of 8 octets in length.  These padding options must be
    recognized by all implementations:</t>

    <t>Pad1 option (alignment requirement: none)</t>

    <figure><artwork align="left"><![CDATA[
   +-+-+-+-+-+-+-+-+
   |       0       |
   +-+-+-+-+-+-+-+-+
]]></artwork></figure>

     <t>Note! the format of the Pad1 option is a special case -- it
     does not have length and value fields.
   </t>
  
    <t>The Pad1 option is used to insert one octet of padding into the
    Options area of a header.  If more than one octet of padding is
    required, the PadN option, described next, should be used, rather
    than multiple Pad1 options.</t>

    <t>PadN option  (alignment requirement: none)</t>
    <figure><artwork align="left"><![CDATA[
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - - -
   |       1       |  Opt Data Len |  Option Data
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - - -
]]></artwork></figure>

    <t>The PadN option is used to insert two or more octets of padding
    into the Options area of a header.  For N octets of padding, the
    Opt Data Len field contains the value N-2, and the Option Data
    consists of N-2 zero-valued octets.</t>

	<t>Appendix A of <xref target="RFC8200"/> contains applicable formatting guidelines for
	   designing new options.</t>
      </section>
      </section>

      <section anchor="UDP-Encapsulation" numbered="true" toc="default">
        <name>UDP Encapsulation</name>
        <t>UDP Encapsulation is done as in
        <xref target="RFC5840"/>.</t>
      </section>
      <section anchor="Packet-format" numbered="true" toc="default">
        <name>Packet format</name>
        <t>The following section defines the resulting packet format. Tunnel
        and Transport Modes are handled exactly the same way as in WESP
        <xref target="RFC5840"/>. The WESPv2 headers are inserted between the
        outer IPv4/IPv6 header and the ESP header. The WESPv2 header MUST be
        inserted before the cryptographic operations. After inserting the
        WESPv2 header, the crypto operations are performed. The full WESPv2
        header, including optional padding and Flow Identifier (FID) MUST be
        included into the integrity protected part of the packet.</t>
      </section>
      <section anchor="IPv4" numbered="true" toc="default">
        <name>IPv4 Datagram</name>
        <figure anchor="ipv4before" align="center">
          <name>IPv4 DATAGRAM BEFORE APPLYING WESP</name>
          <artwork align="left">
            <![CDATA[
            ---------------------------------------------------
            | outer IP hdr  | ESP | ESP Payload |   ESP   |ESP|
            | (any options) | Hdr |    Data     | Trailer |ICV|
            ---------------------------------------------------
                     ]]>
</artwork>
        </figure>
        <figure align="center" anchor="ipv4after">
          <name>IPv4 DATAGRAM AFTER APPLYING WESP</name>
          <artwork align="left">
            <![CDATA[
                      |<- WESPv2 Hdr ->|
        -------------------------------------------------------
        |outer IP hdr |WESP| PAD | FID |ESP| Pyld |  ESP  |ESP|
        |(any options)|BHdr|(opt)|(opt)|Hdr| Data |Trailer|ICV|
        -------------------------------------------------------
                                           |<-encryption->|
                      |<----------- integrity ----------->|

                                ]]>
</artwork>
        </figure>
      </section>
      <section anchor="IPv6" numbered="true" toc="default">
        <name>IPv6 Datagram</name>
        <figure anchor="ipv6before" align="center">
          <name>IPv6 DATAGRAM BEFORE APPLYING WESP</name>
          <artwork align="left">
            <![CDATA[
            -----------------------------------------------------
            |  outer   | ext. | ESP | ESP Payload |   ESP   |ESP|
            | IPv6 Hdr | Hdrs | Hdr |    Data     | Trailer |ICV|
            -----------------------------------------------------
                     ]]>
</artwork>
        </figure>
        <figure align="center" anchor="ipv6after">
          <name>IPv6 DATAGRAM AFTER APPLYING WESP</name>
          <artwork align="left">
            <![CDATA[
                      |<- WESPv2 Hdr ->|
        -------------------------------------------------------
        |  outer |ext.|WESP| PAD | FID |ESP| Pyld |  ESP  |ESP|
        |IPv6 Hdr|Hdrs|BHdr|(opt)|(opt)|Hdr| Data |Trailer|ICV|
        -------------------------------------------------------
                                           |<-encryption->|
                      |<----------- integrity ----------->|

                                ]]>
</artwork>
        </figure>
      </section>
    </section>
    <section anchor="IKENegotiation" numbered="true" toc="default">
      <name>IKEv2 Negotiation</name>
      <t>The IKEv2 negotiation follows exactly the way it is done in WESP
      <xref target="RFC5840"/>, with the difference that a new notification
      USE_WESPv2_MODE is used.</t>
      <t>This document assumes that WESPv2 negotiation is performed using
      IKEv2. In order to negotiate the new format of ESP encapsulation via
      IKEv2
      <xref target="RFC7296"/>, both parties need to agree to use the new
      packet format. This can be achieved using a notification method similar
      to USE_TRANSPORT_MODE, defined in
      <xref target="RFC7296"/>.</t>
      <t>When negotiating a WESPv2 Child SA, USE_WESPv2_MODE MUST be included
      in a either in an IKE_AUTH exchange or CREATE_CHILD_SA. and the rest of
      SA payload necessary for a Child SA using ESP. It signals that the sender
      supports the WESPv2 version defined in the current document and requests
      that the Child SA use WESPv2 mode rather than ESP for the SA created. If
      the request is accepted, the response MUST also include a notification of
      type USE_WESP_MODE. If the responder declines the request, the Child SA
      should be established using ESP, as per
      <xref target="RFC7296"/>. If this is unacceptable to the initiator, the
      initiator MUST delete the Child SA.</t>
      <t>Note: Except when using the options to negotiate WESPv1 or WESPv2
      mode, all CHILD_SAs will use standard ESP.</t>
      <t>Negotiation of WESPv2 in this manner preserves all other negotiation
      parameters, including NAT-T
      <xref target="RFC3948"/>. NAT-T is wholly compatible with this wrapped
      format and can be used as-is, without any modifications, in environments
      where NAT is present and needs to be taken into account.</t>
      <t>WESPv2 version negotiation is not specified here. If the WESP version
      is updated in a future specification, then that document MUST specify how
      the WESP version is negotiated.</t>
      <section title="USE_WESPv2_MODE Payload Format" anchor="payload_formats">
        <t>All multi-octet fields representing integers are laid out in big
        endian order (also known as "most significant byte first", or "network
        byte order").</t>
        <figure align="center">
          <artwork align="left">
            <![CDATA[
                    1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-----------------------------+-------------------------------+
! Next Payload  !C!  RESERVED   !         Payload Length        !
+---------------+---------------+-------------------------------+
!  Protocol ID  !   SPI Size    !      Notify Message Type      !
+---------------+---------------+-------------------------------+
!0|F|CryptOffset!                                               !
+-------------------------------+-------------------------------+
            ]]>
</artwork>
        </figure>
        <ul>
          <li>Protocol ID (1 octet) - MUST be 0. MUST be ignored if not 0.</li>
          <li>SPI Size (1 octet) - MUST be 0. MUST be ignored if not 0.</li>
          <li>Notify Status Message Type value (2 octets) - set to [TBD].</li>
          <li>Notify Payload: bit 0 reserved. bit 1 Flow ID supported. Bits 2-7
          Crypt Offset len in 4 octets</li>
        </ul>
      </section>
    </section>
    <section anchor="IANA" title="IANA Considerations">
      <t>This document defines a new IKEv2 Notify Message Type payloads for the
      IANA "IKEv2 Notify Message Types - Status Types" registry.</t>
      <figure align="center" anchor="iana_requests_i">
        <artwork align="left">
          <![CDATA[
      Value   Notify Type Messages - Status Types    Reference
      -----   ------------------------------    ---------------
      [TBD1]   USE_WESPv2_MODE                      [this document]
            ]]>
</artwork>
      </figure>
    </section>
    <section anchor="Implementation" numbered="true" toc="default">
      <name>Implementation Status</name>
      <t>[Note to RFC Editor: Please remove this section and the reference to
      <xref target="RFC6982"/>before publication.]</t>
      <t>This section records the status of known implementations of the
      protocol defined by this specification at the time of posting of this
      Internet-Draft, and is based on a proposal described in
      <xref target="RFC7942"/>. The description of implementations in this
      section is intended to assist the IETF in its decision processes in
      progressing drafts to RFCs. Please note that the listing of any
      individual implementation here does not imply endorsement by the IETF.
      Furthermore, no effort has been spent to verify the information presented
      here that was supplied by IETF contributors. This is not intended as, and
      must not be construed to be, a catalog of available implementations or
      their features. Readers are advised to note that other implementations
      may exist.</t>
      <t>According to
      <xref target="RFC7942"/>, "this will allow reviewers and working groups
      to assign due consideration to documents that have the benefit of running
      code, which may serve as evidence of valuable experimentation and
      feedback that have made the implemented protocols more mature. It is up
      to the individual working groups to use this information as they see
      fit".</t>
      <t>Authors are requested to add a note to the RFC Editor at the top of
      this section, advising the Editor to remove the entire section before
      publication, as well as the reference to
      <xref target="RFC7942"/>.</t>
      <!--
      <section anchor="impl-status.Linux.xfrm" title="Linux XFRM">
        <t>Linux</t>
        <dl>
          <dt>Organization:</dt>
          <dd>Linux kernel Project</dd>
          <dt>Name:</dt>
          <dd>Linux Kernel https://www.kernel.org/</dd>
          <dt>Description:</dt>
          <dd>Not implemented</dd>
          <dt>Level of maturity:</dt>
          <dd>None</dd>
          <dt>Licensing:</dt>
          <dd>GPLv2</dd>
          <dt>Implementation experience:</dt>
          <dd>TBD</dd>
          <dt>Contact:</dt>
          <dd>https://lore.kernel.org/netdev/</dd>
        </dl>
      </section>
      <section anchor="section.impl-status.strongswan" title="strongSwan">
        <dl>
          <dt>Organization:</dt>
          <dd>The strongSwan Project</dd>
          <dt>Name:</dt>
          <dd>strongSwan
          https://docs.strongswan.org/docs/5.9/swanctl/swanctlConf.html</dd>
          <dt>Description:</dt>
          <dd>Not implemented</dd>
          <dt>Level of maturity:</dt>
          <dd>None</dd>
          <dt>Coverage:</dt>
          <dd>TBD</dd>
          <dt>Licensing:</dt>
          <dd>GPLv2</dd>
          <dt>Implementation experience</dt>
          <dd>TBD</dd>
          <dt>Contact</dt>
          <dd>TBD</dd>
        </dl>
      </section>
   -->
    </section>
    <section anchor="Security" numbered="true" toc="default">
      <name>Security Considerations</name>
      <t>In this section we discuss the security properties of WESPv2: TBD</t>
      <!--
      <t>
      Some text ...
   </t>
   -->
    </section>
    <section anchor="Acknowledgements" numbered="true" toc="default">
      <name>Acknowledgments</name>
      <t>TBD</t>
    </section>
  </middle>
  <back>
    <references>
      <name>Normative References</name>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3948.xml"/>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4303.xml"/>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5840.xml"/>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7296.xml"/>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2992.xml"/>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8200.xml"/>
      <!--
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4301.xml"/>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.791.xml"/>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8200.xml"/>
      -->
    </references>
    <references>
      <name>Informative References</name>
      <!--
      <xi:include href="https://bib.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-ipsecme-multi-sa-performance.xml"/>
      -->
      <xi:include href="https://bib.ietf.org/public/rfc/bibxml3/reference.I-D.mrossberg-ipsecme-multiple-sequence-counters.xml"/>
      <xi:include href="https://bib.ietf.org/public/rfc/bibxml3/reference.I-D.ponchon-ipsecme-anti-replay-subspaces.xml"/>
      <xi:include href="https://bib.ietf.org/public/rfc/bibxml3/reference.I-D.he-ipsecme-vpn-shared-ipsecsa.xml"/>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6982.xml"/>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7942.xml"/>
      <reference anchor="PSP"
      target="https://github.com/google/psp/blob/main/doc/PSP_Arch_Spec.pdf"
      quoteTitle="true">
        <front>
          <title>PSP Architecture Specification</title>
          <author>
            <organization showOnFrontPage="true">Google</organization>
          </author>
        </front>
      </reference>
      <!--
      <reference anchor="NVIDIA-PSP"
      target="https://docs.nvidia.com/doca/sdk/nvidia+doca+psp+gateway+application+guide/index.html"
      quoteTitle="true">
        <front>
          <title>NVIDIA DOCA PSP Gateway Application Guide</title>
          <author>
            <organization showOnFrontPage="true">NVIDIA</organization>
          </author>
        </front>
      </reference>
      -->
      <!--
      <reference anchor="Google-PSPS-Support" target="https://cloud.google.com/blog/products/identity-security/announcing-psp-security-protocol-is-now-open-source" quoteTitle="true">
        <front>
          <title>NVIDIA DOCA PSP Gateway Application Guide</title>
          <author>
                                                <organization showOnFrontPage="true">NVIDIA</organization>
          </author>
                    </front>
      </reference>
                        -->
    </references>
    <section anchor="app-additional" numbered="true" toc="default">
      <name>Additional Stuff</name>
      <t>TBD</t>
    </section>
  </back>
</rfc>
