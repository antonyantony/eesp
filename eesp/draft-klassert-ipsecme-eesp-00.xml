<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- <xi:strict="yes" ?>
<xi:compact="yes" ?>
<xi:subcompact="no" ?>  -->
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" category="std"
docName="draft-klassert-ipsecme-eesp-00" ipr="trust200902" obsoletes="" updates=""
submissionType="IETF" xml:lang="en" tocInclude="true" tocDepth="4"
symRefs="true" sortRefs="true" version="3" consensus="true">
  <front>
    <!-- The abbreviated title is used in the page header - it is only necessary if the
        full title is longer than 39 characters -->
    <title abbrev="EESP">Enhanced ESP</title>
    <!-- add 'role="editor"' below for the editors if appropriate -->
    <!-- Another author who claims to be an editor -->
    <author fullname="Steffen Klassert" initials="S." surname="Klassert">
      <organization abbrev="secunet">secunet Security Networks AG</organization>
      <address>
        <email>steffen.klassert@secunet.com</email>
      </address>
    </author>
    <author initials="A." surname="Antony" fullname="Antony Antony">
      <organization abbrev="secunet">secunet Security Networks AG</organization>
      <address>
        <email>antony.antony@secunet.com</email>
      </address>
    </author>
    <area>sec</area>
    <workgroup>IPSECME Working Group</workgroup>
    <keyword>IKEv2</keyword>
    <keyword>EESP</keyword>
    <abstract>
      <t>This document describes the Enhanced Encapsulating Security Payload
      (EESP) protocol, which builds on the Encapsulating Security Payload
      (ESP)
      <xref target="RFC4303"/>. It is designed to overcome limitations of the
      ESP protocol to expose inner flow information to the network in a transparent
      way. To do so, it adapts IPv6 Extension header options to EESP
      where flow identitiers can be stored. 
      </t>
    </abstract>
  </front>
  <middle>
    <section numbered="true" toc="default">
      <name>Introduction</name>
      <t>Due to the absence of a
      version number in the ESP protocol, in the packet header, ESP can't be
      updated in a transparent way. Any updates to ESP must be negotiated by
      IKEv2 and for that, indiscernible to intermediate devices such as routers
      and firewalls. In the recent past, several attempts were taken to
      introduce a Flow Identifier for certain use-cases. Examples are
      <xref target="I-D.ponchon-ipsecme-anti-replay-subspaces"/> and
      <xref target="I-D.he-ipsecme-vpn-shared-ipsecsa"/>. Such a Flow
      Identifier could also be used to perform ECMP based on the inner flows at
      intermediate devices or endpoints. Additionally to that, there exists a
      specification of the
      <xref target="PSP"/> protocol that has the need of a Flow Identifier,
      called
      Network Identifier (VNI) there. PSP also defines a Crypto Offset to expose
      parts of the headers of the inner packet.

      EESP provides a solution for all the aforementioned use-cases.</t>
      <t> This document defines Options for the PSP usecase.
      Future documents can define the meaning of
      additional Options for their particular use-case. With this, all existing and
      potential new use-cases for Flow Identifiers can be covered. For
      instance it can be used for the case of
      <xref target="I-D.ponchon-ipsecme-anti-replay-subspaces"/> or
      <xref target="I-D.he-ipsecme-vpn-shared-ipsecsa"/> etc., or combinations
      thereof. A detailed discussion about the
      problems of the ESP protocol can be found in
      <xref target="I-D.mrossberg-ipsecme-multiple-sequence-counters"/>.</t>
      <t>Though this document specifies IKEv2 as a negotiation protocol, EESP
      may use other protocols for negotiation and key derivation. The packet
      specification is portable to other key protocol use cases, such as
      <xref target="PSP"/>, and offers versioning at the packet level.</t>
      <section numbered="true" toc="default">
        <name>Requirements Language</name>
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
        document are to be interpreted as described in
        <xref target="RFC2119" format="default">RFC 2119</xref>.</t>
      </section>
      <section numbered="true" toc="default">
        <name>Terminology</name>
        <t>This document uses the following terms defined in IKEv2
        <xref target="RFC7296"/>: Child SA, CREATE_CHILD_SA, IKE_AUTH
        exchange, USE_TRANSPORT_MODE</t>
        <t>This document uses the following terms defined in
        <xref target="PSP"/>: PSP (a recursive acronym for PSP Security
        Protocol), Network Identifier (VNI), Crypt Offset.</t>
        <t>This document uses the following terms defined in
        <xref target="RFC5840"/>: Wrapped Encapsulating Security Payload
        (WESP), USE_WESP_MODE.</t>
        <t>This document uses the following terms defined in
        <xref target="RFC2992"/>: Equal-cost multi-path (ECMP)</t>
        <t>This document uses the following terms defined in
        <xref target="RFC4303"/>: Encapsulating Security Payload (ESP).</t>
        <t>This document uses the following terms defined in
        <xref target="I-D.mrossberg-ipsecme-multiple-sequence-counters"/>:
        Sub-Child SA.</t>
      </section>
    </section>
    <section anchor="Protocol-definition" numbered="true" toc="default">
      <name>Protocol Definition</name>
      <t>In this section we define the exact protocol formats and operations.
      This section is normative.</t>
      <section anchor="WESPv2-header-format" numbered="true" toc="default">
        <name>EESP packet format</name>
        <t>
        The (outer) protocol header (IPv4, IPv6, or Extension) that
        immediately precedes the ESP header SHALL contain the value TBD in its
        Protocol (IPv4) or Next Header (IPv6, Extension) field (see IANA web
        page at http://www.iana.org/assignments/protocol-numbers).  Figure 1
        illustrates the top-level format of an EESP packet.
        The EESP header is split into multiple parts.
	The packet begins
        with a 4 byte base header that is always
        present and an optional part directly following the base header.

       This follows the two, from ESP well known, 4-byte fields Security Parameters Index
       (SPI) and Sequence Number.
        Unlike ESP, EESP does not have
	a trailer. Instead, the next header and pad length fields directly follow
	the header, or the IV if present. 


       Following these fields is the Payload Data, which has
       substructure that depends on the choice of encryption algorithm and
       mode.  Following the Payload Data is the optional Integrity Check Value (ICV)
        field that completes the packet.

	The
        base header essentially defines the total length of the EESP header
	and the length of potential present options as well as the EESP version number.
	The optional
        part of the header defines Options to store additional information, like
	integrity protected flow identifiers that can be used for flow classification. </t>
        <t>The header is constructed in a way that the start of the following next header
        is aligned on a 4 byte boundary on IPv4 and on a  8 byte boundary on IPv6
	respective the start of the IPv4/IPv6 header.</t>


        <!--
   <t>
   FIXME: Remove this block before publishing.
       IPv4:
           NET_IP_ALIGN(2) + ethernet_header(14) + IP_header(20) + wesp_base_header(4)
           + padding(8) + FID(8) + ESP(8)
   </t>
   <t>
        IPv6:
           NET_IP_ALIGN(2) + ethernet_header(14) + IP_header(40) + wesp_base_header(4)
           + padding(4) + FID(8) + ESP(8)
   </t>
   -->
        <figure align="center" anchor="eesp-packet-format">
          <name>EESP packet format</name>
          <artwork align="left">
            <![CDATA[


    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |        R      |    HdrLen     |   Optlen  |   R   | Version   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   ~                             Options                           ~
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                              SPI                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Sequence Number                        |
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          IV* (optional)                       |
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Next Header   | Pad Length    |             R                 |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      Payload Data (variable)                  |
   ~                                                               ~
   |               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               |          Padding (0-255 bytes)                |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   ~              Integrity Check Value-ICV (variable)             ~
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        ]]>
</artwork>
        </figure>
	<t>
	* If included, cryptographic synchronization
        data, e.g., an Initialization Vector (IV, see Section ?!),
        usually is not encrypted per se, although it often is referred
        to as being part of the ciphertext. Unlike ESP, the IV is not considered
	to be a part of the payload data in EESP.
	</t>

	<t>
   If a combined algorithm mode is employed, the explicit ICV shown in
   Figures 1 and 2 may be omitted (see Section ?! below).  Because
   algorithms and modes are fixed when an SA is established, the
   detailed format of ESP packets for a given SA (including the Payload
   Data substructure) is fixed, for all traffic on the SA.
   </t>

     <t>
   The tables below refer to the fields in the preceding figures and
   illustrate how several categories of algorithmic options, each with a
   different processing model, affect the fields noted above.  The
   processing details are described in later sections.
	</t>

        <figure align="center" anchor="eesp-packet-separate-algos">
          <name>Separate Encryption and Integrity Algorithms</name>
          <artwork align="left">
            <![CDATA[
                                            What    What    What
                          # of     Requ'd  Encrypt Integ    is
                          bytes      [1]   Covers  Covers  Xmtd
                          ------   ------  ------  ------  ------
   Base Header               4        M              Y     plain
   Options                variable    O              Y     plain
   SPI                       4        M              Y     plain
   Seq#                      8        M              Y     plain       p
   IV                     variable    O              Y     plain       y
   Next Header               1        M       Y      Y     cipher[3]
   Pad Length                1        M       Y      Y     cipher[3]
   Reserved                  2        M       Y      Y     cipher[3]
                                                                ------
   IP datagram [2]        variable  M or D    Y      Y     cipher[3] |-l
                                                                ------ a
   Padding                 0-255      M       Y      Y     cipher[3]   d
   ICV Padding            variable if need           Y     not xmtd
   ICV                    variable   M [4]                 plain

           [1] M = mandatory; O = optional; D = dummy
           [2] If tunnel mode -> IP datagram
               If beet mode -> IP datagram
               If transport mode -> next header and data
           [3] ciphertext if encryption has been selected
           [4] mandatory if a separate integrity algorithm is used
        ]]>
</artwork>
        </figure>


        <figure align="center" anchor="eesp-packet-combined-algos">
          <name>Combined Mode Algorithms</name>
          <artwork align="left">
            <![CDATA[
                                             What    What    What
                          # of     Requ'd  Encrypt Integ    is
                          bytes      [1]   Covers  Covers  Xmtd
                          ------   ------  ------  ------  ------
   Base Header               4        M              Y     plain
   Options                variable    O              Y     plain
   SPI                       4        M              Y     plain
   Seq#                      8        M              Y     plain       p
   IV                     variable    O              Y     plain       y
   Next Header               1        M       Y      Y     cipher
   Pad Length                1        M       Y      Y     cipher
   Reserved                  2        M       Y      Y     cipher
                                                                ------
   IP datagram [2]        variable  M or D    Y      Y     cipher    |-l
                                                                ------ a
   Padding                 0-255      M       Y      Y     cipher      d
   ICV Padding            variable if need           Y     [3]
   ICV                    variable   O [4]                 plain

            [1] M = mandatory; O = optional; D = dummy
            [2] If tunnel mode -> IP datagram
                If beet mode -> IP datagram
                If transport mode -> next header and data
            [3] The algorithm choices determines whether these are
                transmitted, but in either case, the result is invisible
                to ESP
            [4] The algorithm spec determines whether this field is
                present
        ]]>
</artwork>
        </figure>

        <t>
         The following subsections describe the fields in the header format.
         "Optional" means that the field is omitted if the option is not
         selected, i.e., it is present in neither the packet as transmitted
         nor as formatted for computation of an ICV (see Section 2.7).
         Whether or not an option is selected is determined as part of
         Security Association (SA) establishment.  Thus, the format of EESP
         packets for a given SA is fixed, for the duration of the SA.  In
         contrast, "mandatory" fields are always present in the EESP packet
         format, for all SAs.
	</t>

      </section>

      <section anchor="Base-Header" numbered="true" toc="default">
        <name>Base Header</name>
        <ul>
          <li>Reserved - 8 bits: Set to zero on transmit, ignored on
          receive.
          </li>
          <li>HdrLen - 8 bits: Offset from the beginning of the EESP header
          to the beginning of the Payload Data (i.e., past the IV, if
          present) within, in octet. The following HdrLen values
          are invalid: any value less than 16; any value that is not a multiple
          of 4; any value that is not a multiple of 8 when using IPv6. The
          receiver MUST ensure that this field matches with the header offset
          computed from using the negotiated Security Association (SA) and MUST
          drop the packet in case it does not match.</li>
          <li>OptLen - 6 bit: Total length of all options included in the WESPv2
	  header Options, in octets.
          </li>
          <li>Reserved - 4 bits: Set to zero on transmit, ignored on
          receive.</li>
          <li>Version (V) - 6 bits: MUST be sent to zero and checked by the
          receiver. If the version is different than an expected version number
          (e.g., negotiated via the control channel), then the packet MUST be
          dropped by the receiver. Future modifications to the EESP header
          require a new version number. In particular, the version of EESP
          defined in this document does not allow for any extensions.
          Intermediate nodes dealing with unknown
          versions are not necessarily able to parse the packet correctly.
          Intermediate treatment of such packets is policy dependent (e.g., it
          may dictate dropping such packets).</li>
        </ul>

	</section>

      <section anchor="Options" numbered="true" toc="default">
        <name>Options</name>
	<t>EESP options carry a variable number of "options" that are
	type-length- value (TLV) encoded in the same format as done in
	<xref target="RFC8200"/> Section 4.2 for IPv6 extension headers.
	This document defines three different option classes, Padding Options,
	Flow Identifier Options and Private Options.</t>
	<t>Padding Options MUST be used to align the start of the next
	header to the natural alignment of the protocol, i.e. 4 byte for IPv4
	and 8 byte for IPv6. Other padding, like padding for cipher text alignment,
	is out of the scope of this document. Future documents can define this
	by using the existing padding options. Additional padding MUST be
	negotiated by IKEv2 or any other suitable protocol.</t>

	<t>
	Flow Identifier Options MUST carry characteristic information of the inner flow, i.e.
	MUST NOT change on per packet basis. It MUST be negotiated by
	IKEv2 or any other suitable protocol.

	The detailed specification of
	Flow Identifiers MUST be provided in subsequent documents. These Options are
	opaque to intermediate devices; however, intermediate routers MAY use
	it for identifying flows for ECMP or similar purposes. e.g. Sub-Child
	SAs, in <xref target="I-D.mrossberg-ipsecme-multiple-sequence-counters"/>could
	be encoded here. Flow Identifiers MUST have the format of Options
	as defind in <xref target="Adapt-Options"/>.
	</t>

	<t>Private Options comming from a reserved Option Type Range and
	can be used for any purposes that are out of scope for standardization.
	For example it can be used to encode hardware specific information,
	such as used encryption/authentication algorithms as done in <xref target="PSP"/>.</t>

	<t>The only EESP Option Types defined in this document are the Pad1 and
	   PadN options specified in <xref target="Adapt-Options"/>.</t>

  <section title=" Adapting IPv6 Extension header options" anchor="Adapt-Options">

	<t>EESP extension header Options are adapted from IPv6 extension header Options as
	   defined in Section 4.2 of <xref target="RFC8200"/>, with the following modifications:</t>

	<ul>
	<li>References to the IPv6 header are removed. </li>
	<li>The two highest-order bits of the Option Type MUST be set to 00, if the Option
	Type comes from the private range. </li>
	<li>The third-highest-order bit of the Option Type MUST be set to 0. </li>
	<li>References to the Hop-by-Hop
	   Options header and the Destination Options header are removed.</li>
	</ul>

	</section>

  <section title=" EESP Extension header options" anchor="EESP-Options">

    <t>EESP Options
     carry a variable number of type-length-value (TLV) encoded
    "options", of the following format:</t>

    <figure><artwork align="left"><![CDATA[
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - - -
   |  Option Type  |  Opt Data Len |  Option Data
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - - -
   ]]></artwork></figure>

	<ul>
	<li> Option Type: 8-bit identifier of the type of option.</li>
      <li> Opt Data Len: 8-bit unsigned integer.  Length of
      the Option Data field of this option, in octets.</li>
      <li> Option Data: Variable-length field. Option-Type-specific data.</li>
	</ul>

    <t>The sequence of options within a header must be processed
    strictly in the order they appear in the header; a receiver must
    not, for example, scan through the header looking for a particular
    kind of option and process that option prior to processing all
    preceding ones.</t>

    <t>The Option Type identifiers are internally encoded such that
    their highest-order two bits specify the action that must be taken
    if the processing node does not recognize the Option Type:</t>

	<ul>
	<li> 00 - skip over this option and continue processing
      the header.</li>
      <li> 01 - discard the packet.</li>
      <li> 10 - discard the packet and, regardless of whether
      or not the packet's Destination Address was a multicast address,
      send an ICMP Parameter Problem, Code 2, message to the packet's
      Source Address, pointing to the unrecognized Option Type.</li>
      <li> 11 - discard the packet and, only if the packet's
      Destination Address was not a multicast address, send an ICMP
      Parameter Problem, Code 2, message to the packet's Source
      Address, pointing to the unrecognized Option Type.</li>
	</ul>

	<t>Options from the private range MUST set the two
	highest-order bit to 00.</t>

    <t>The third-highest-order bit of the Option Type specifies
    whether or not the Option Data of that option can change en-route
    to the packet's final destination. That bit is left in to be
    compliant with IPv6 extenstion header options. EESP
    options are authenticated, therefore this bit MUST be set to 0.
    </t>

	<ul>
	<li>0 - Option Data does not change en-route</li>
      <li>1 - Option Data may change en-route</li>
	</ul>

    <t>The three high-order bits described above are to be treated as
    part of the Option Type, not independent of the Option Type.  That
    is, a particular option is identified by a full 8-bit Option Type,
    not just the low-order 5 bits of an Option Type.</t>

    <t>Individual options may have specific alignment requirements, to
    ensure that multi-octet values within Option Data fields fall on
    natural boundaries.  The alignment requirement of an option is
    specified using the notation xn+y, meaning the Option Type must
    appear at an integer multiple of x octets from the start of the
    header, plus y octets.  For example:</t>

      <?rfc subcompact="yes" ?>
      <ul>
      <li>2n means any 2-octet offset from the start of the header.</li>
      <li>8n+2 means any 8-octet offset from the start of the header,
      plus 2 octets.</li>
	</ul>

    <?rfc subcompact="no" ?>

    <t>There are two padding options which are used when necessary to
    align subsequent options and to pad out the containing header to a
    multiple of 8 octets in length.  These padding options must be
    recognized by all implementations:</t>

    <t>Pad1 option (alignment requirement: none)</t>

    <figure><artwork align="left"><![CDATA[
   +-+-+-+-+-+-+-+-+
   |       0       |
   +-+-+-+-+-+-+-+-+
]]></artwork></figure>

     <t>Note! the format of the Pad1 option is a special case -- it
     does not have length and value fields.
   </t>

    <t>The Pad1 option is used to insert one octet of padding into the
    Options area of a header.  If more than one octet of padding is
    required, the PadN option, described next, should be used, rather
    than multiple Pad1 options.</t>

    <t>PadN option  (alignment requirement: none)</t>
    <figure><artwork align="left"><![CDATA[
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - - -
   |       1       |  Opt Data Len |  Option Data
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - - -
]]></artwork></figure>

    <t>The PadN option is used to insert two or more octets of padding
    into the Options area of a header.  For N octets of padding, the
    Opt Data Len field contains the value N-2, and the Option Data
    consists of N-2 zero-valued octets.</t>

	<t>Appendix A of <xref target="RFC8200"/> contains applicable formatting guidelines for
	   designing new options.</t>
      </section>
      </section>

      <section anchor="SPI" numbered="true" toc="default">
        <name>Security Parameters Index (SPI)</name>
        <t>The Security Parameters Index (SPI) is handled as in
        <xref target="RFC4303"/>.</t>
      </section>

      <section anchor="Sequence-Number" numbered="true" toc="default">
        <name>Sequence Number</name>

	<t>
        FIXME: This section is not yet correct!!!
	</t>
        <t>
   This unsigned 64-bit field contains a counter value that increases by
   one for each packet sent, i.e., a per-SA packet sequence number.  For
   a unicast SA or a single-sender multicast SA, the sender MUST
   increment this field for every transmitted packet.  Sharing an SA
   among multiple senders is permitted, though generally not
   recommended.  ESP provides no means of synchronizing packet counters
   among multiple senders or meaningfully managing a receiver packet
   counter and window in the context of multiple senders.  Thus, for a
   multi-sender SA, the anti-replay features of ESP are not available
   (see Sections 3.3.3 and 3.4.3.)
    </t>

      <t>
   The field is mandatory and MUST always be present even if the
   receiver does not elect to enable the anti-replay service for a
   specific SA.  Processing of the Sequence Number field is at the
   discretion of the receiver, but all ESP implementations MUST be
   capable of performing the processing described in Sections 3.3.3 and
   3.4.3. Thus, the sender MUST always transmit this field, but the
   receiver need not act upon it (see the discussion of Sequence Number
   Verification in the "Inbound Packet Processing" section (3.4.3)
   below).
    </t>

    <t>
   The sender's counter and the receiver's counter are initialized to 0
   when an SA is established.  (The first packet sent using a given SA
   will have a sequence number of 1; see Section 3.3.3 for more details
   on how the sequence number is generated.)  If anti-replay is enabled
   (the default), the transmitted sequence number must never be allowed
   to cycle.  Thus, the sender's counter and the receiver's counter MUST
   be reset (by establishing a new SA and thus a new key) prior to the
   transmission of the 2^32nd packet on an SA.
       </t>
      </section>

      <section anchor="IV" numbered="true" toc="default">
        <name>Initialization Vector</name>
        <t>
   If the algorithm used to encrypt the payload requires cryptographic
   synchronization data, e.g., an Initialization Vector (IV), then this
   data is carried explicitly in front of the encrypted part of the packet.
   but it is not called. Any encryption algorithm
   that requires such explicit, per-packet synchronization data MUST
   indicate the length, any structure for such data, and the location of
   this data as part of an RFC specifying how the algorithm is used with
   EESP.  (Typically, the IV immediately precedes the ciphertext.  See
   Figure ?!.)  If such synchronization data is implicit, the algorithm
   for deriving the data MUST be part of the algorithm definition RFC.
   (If included, cryptographic synchronization
   data, e.g., an Initialization Vector (IV), usually is not encrypted
   per se (see Tables 1 and 2), although it sometimes is referred to as
   being part of the ciphertext.)
      </t>

      <t>
      Counter mode algorithms MAY encode the Initialization Vector (IV)
      on the Sequence number Field.
         Whether or not this option is selected is determined as part of
         Security Association (SA) establishment.
      </t>
      </section>

      <section anchor="Next-Header" numbered="true" toc="default">
        <name>Next Header</name>
        <t>
   The Next Header is a mandatory, 8-bit field that identifies the type
   of data contained in the Payload Data field, e.g., an IPv4 or IPv6
   packet, or a next layer header and data.  The value of this field is
   chosen from the set of IP Protocol Numbers defined on the web page of
   the IANA, e.g., a value of 4 indicates IPv4, a value of 41 indicates
   IPv6, and a value of 6 indicates TCP.
	</t>
      </section>

      <section anchor="Pad-Length" numbered="true" toc="default">
        <name>Pad Length</name>
        <t>
   The Pad Length field indicates the number of pad bytes immediately
   preceding it in the Padding field.  The range of valid values is 0 to
   255, where a value of zero indicates that no Padding bytes are
   present. The Pad Length field is mandatory.
        </t>
      </section>


      <section anchor="Payload-Data" numbered="true" toc="default">
        <name>Payload Data</name>
        <t>UDP Encapsulation is done as in
        <xref target="RFC5840"/>.</t>
      </section>

      <section anchor="Padding" numbered="true" toc="default">
        <name>Padding (for Encryption)</name>
        <t>

      </t>
      </section>

      <section anchor="ICV" numbered="true" toc="default">
        <name>Integrity Check Value (ICV)</name>
        <t>Integrity Check Value is handled as in
        <xref target="RFC4303"/>.</t>
      </section>


<!-- Everyting below here is not yet converted! -->

      <section anchor="UDP-Encapsulation" numbered="true" toc="default">
        <name>UDP Encapsulation</name>
        <t>UDP Encapsulation is done as in
        <xref target="RFC5840"/>.</t>
      </section>
      <section anchor="Packet-format" numbered="true" toc="default">
        <name>Packet format</name>
        <t>The following section defines the resulting packet format. Tunnel
        and Transport Modes are handled exactly the same way as in WESP
        <xref target="RFC5840"/>. The WESPv2 headers are inserted between the
        outer IPv4/IPv6 header and the ESP header. The WESPv2 header MUST be
        inserted before the cryptographic operations. After inserting the
        WESPv2 header, the crypto operations are performed. The full WESPv2
        header, including all header Options MUST be
        included into the integrity protected part of the packet.</t>
      </section>
      <section anchor="IPv4" numbered="true" toc="default">
        <name>IPv4 Datagram</name>
        <figure anchor="ipv4before" align="center">
          <name>IPv4 DATAGRAM BEFORE APPLYING WESP</name>
          <artwork align="left">
            <![CDATA[
            ---------------------------------------------------
            | outer IP hdr  | ESP | ESP Payload |   ESP   |ESP|
            | (any options) | Hdr |    Data     | Trailer |ICV|
            ---------------------------------------------------
                     ]]>
</artwork>
        </figure>
        <figure align="center" anchor="ipv4after">
          <name>IPv4 DATAGRAM AFTER APPLYING WESP</name>
          <artwork align="left">
            <![CDATA[
                      |<-WESPv2 Hdr->|
        -------------------------------------------------------
        |outer IP hdr | WESP |  OPT  | ESP | Pyld |  ESP  |ESP|
        |(any options)| BHdr | (var) | Hdr | Data |Trailer|ICV|
        -------------------------------------------------------
                                           |<-encryption->|
                      |<----------- integrity ----------->|

                                ]]>
</artwork>
        </figure>
      </section>
      <section anchor="IPv6" numbered="true" toc="default">
        <name>IPv6 Datagram</name>
        <figure anchor="ipv6before" align="center">
          <name>IPv6 DATAGRAM BEFORE APPLYING WESP</name>
          <artwork align="left">
            <![CDATA[
            -----------------------------------------------------
            |  outer   | ext. | ESP | ESP Payload |   ESP   |ESP|
            | IPv6 Hdr | Hdrs | Hdr |    Data     | Trailer |ICV|
            -----------------------------------------------------
                     ]]>
</artwork>
        </figure>
        <figure align="center" anchor="ipv6after">
          <name>IPv6 DATAGRAM AFTER APPLYING WESP</name>
          <artwork align="left">
            <![CDATA[
                      |<-WESPv2 Hdr->|
        -------------------------------------------------------
        |  outer |ext.| WESP |  OPT  | ESP | Pyld |  ESP  |ESP|
        |IPv6 Hdr|Hdrs| BHdr | (var) | Hdr | Data |Trailer|ICV|
        -------------------------------------------------------
                                           |<-encryption->|
                      |<----------- integrity ----------->|

                                ]]>
</artwork>
        </figure>
      </section>
    </section>
    <section anchor="IKENegotiation" numbered="true" toc="default">
      <name>IKEv2 Negotiation</name>
      <t>The IKEv2 negotiation follows exactly the way it is done in WESP
      <xref target="RFC5840"/>, with the difference that a new notification
      USE_WESPv2_MODE is used.</t>
      <t>This document assumes that WESPv2 negotiation is performed using
      IKEv2. In order to negotiate the new format of ESP encapsulation via
      IKEv2
      <xref target="RFC7296"/>, both parties need to agree to use the new
      packet format. This can be achieved using a notification method similar
      to USE_TRANSPORT_MODE, defined in
      <xref target="RFC7296"/>.</t>
      <t>When negotiating a WESPv2 Child SA, USE_WESPv2_MODE MUST be included
      in a either in an IKE_AUTH exchange or CREATE_CHILD_SA. and the rest of
      SA payload necessary for a Child SA using ESP. It signals that the sender
      supports the WESPv2 version defined in the current document and requests
      that the Child SA use WESPv2 mode rather than ESP for the SA created. If
      the request is accepted, the response MUST also include a notification of
      type USE_WESP_MODE. If the responder declines the request, the Child SA
      should be established using ESP, as per
      <xref target="RFC7296"/>. If this is unacceptable to the initiator, the
      initiator MUST delete the Child SA.</t>
      <t>Note: Except when using the options to negotiate WESPv1 or WESPv2
      mode, all CHILD_SAs will use standard ESP.</t>
      <t>Negotiation of WESPv2 in this manner preserves all other negotiation
      parameters, including NAT-T
      <xref target="RFC3948"/>. NAT-T is wholly compatible with this wrapped
      format and can be used as-is, without any modifications, in environments
      where NAT is present and needs to be taken into account.</t>
      <t>WESPv2 version negotiation is not specified here. If the WESP version
      is updated in a future specification, then that document MUST specify how
      the WESP version is negotiated.</t>
      <section title="USE_WESPv2_MODE Payload Format" anchor="payload_formats">
        <t>All multi-octet fields representing integers are laid out in big
        endian order (also known as "most significant byte first", or "network
        byte order").</t>
        <figure align="center">
          <artwork align="left">
            <![CDATA[
                    1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-----------------------------+-------------------------------+
! Next Payload  !C!  RESERVED   !         Payload Length        !
+---------------+---------------+-------------------------------+
!  Protocol ID  !   SPI Size    !      Notify Message Type      !
+---------------+---------------+-------------------------------+
!0|F|CryptOffset!                                               !
+-------------------------------+-------------------------------+
            ]]>
</artwork>
        </figure>
        <ul>
          <li>Protocol ID (1 octet) - MUST be 0. MUST be ignored if not 0.</li>
          <li>SPI Size (1 octet) - MUST be 0. MUST be ignored if not 0.</li>
          <li>Notify Status Message Type value (2 octets) - set to [TBD].</li>
          <li>Notify Payload: bit 0 reserved. bit 1 Flow ID supported. Bits 2-7
          Crypt Offset len in 4 octets</li>
        </ul>
      </section>
    </section>
    <section anchor="IANA" title="IANA Considerations">
      <t>This document defines a new IKEv2 Notify Message Type payloads for the
      IANA "IKEv2 Notify Message Types - Status Types" registry.</t>
      <figure align="center" anchor="iana_requests_i">
        <artwork align="left">
          <![CDATA[
      Value   Notify Type Messages - Status Types    Reference
      -----   ------------------------------    ---------------
      [TBD1]   USE_WESPv2_MODE                  [this document]
            ]]>
</artwork>
      </figure>



      <t>This document requests IANA to create a registry called
      "WESP_OPTIONS Type Registry" under a new category named
      "WESP_OPTIONS Parameters". This initial content for this registry is as follows:</t>
      <figure align="center" anchor="iana_requests_reg">
        <artwork align="left">
          <![CDATA[
      Value   WESP Header Options Types          Reference
      -----   ------------------------------    ---------------
          0   Pad1                              [this document]
          1   PadN                              [this document]
      27-31   Private                           [this document]
            ]]>
</artwork>
      </figure>

    </section>
    <section anchor="Implementation" numbered="true" toc="default">
      <name>Implementation Status</name>
      <t>[Note to RFC Editor: Please remove this section and the reference to
      <xref target="RFC6982"/>before publication.]</t>
      <t>This section records the status of known implementations of the
      protocol defined by this specification at the time of posting of this
      Internet-Draft, and is based on a proposal described in
      <xref target="RFC7942"/>. The description of implementations in this
      section is intended to assist the IETF in its decision processes in
      progressing drafts to RFCs. Please note that the listing of any
      individual implementation here does not imply endorsement by the IETF.
      Furthermore, no effort has been spent to verify the information presented
      here that was supplied by IETF contributors. This is not intended as, and
      must not be construed to be, a catalog of available implementations or
      their features. Readers are advised to note that other implementations
      may exist.</t>
      <t>According to
      <xref target="RFC7942"/>, "this will allow reviewers and working groups
      to assign due consideration to documents that have the benefit of running
      code, which may serve as evidence of valuable experimentation and
      feedback that have made the implemented protocols more mature. It is up
      to the individual working groups to use this information as they see
      fit".</t>
      <t>Authors are requested to add a note to the RFC Editor at the top of
      this section, advising the Editor to remove the entire section before
      publication, as well as the reference to
      <xref target="RFC7942"/>.</t>
      <!--
      <section anchor="impl-status.Linux.xfrm" title="Linux XFRM">
        <t>Linux</t>
        <dl>
          <dt>Organization:</dt>
          <dd>Linux kernel Project</dd>
          <dt>Name:</dt>
          <dd>Linux Kernel https://www.kernel.org/</dd>
          <dt>Description:</dt>
          <dd>Not implemented</dd>
          <dt>Level of maturity:</dt>
          <dd>None</dd>
          <dt>Licensing:</dt>
          <dd>GPLv2</dd>
          <dt>Implementation experience:</dt>
          <dd>TBD</dd>
          <dt>Contact:</dt>
          <dd>https://lore.kernel.org/netdev/</dd>
        </dl>
      </section>
      <section anchor="section.impl-status.strongswan" title="strongSwan">
        <dl>
          <dt>Organization:</dt>
          <dd>The strongSwan Project</dd>
          <dt>Name:</dt>
          <dd>strongSwan
          https://docs.strongswan.org/docs/5.9/swanctl/swanctlConf.html</dd>
          <dt>Description:</dt>
          <dd>Not implemented</dd>
          <dt>Level of maturity:</dt>
          <dd>None</dd>
          <dt>Coverage:</dt>
          <dd>TBD</dd>
          <dt>Licensing:</dt>
          <dd>GPLv2</dd>
          <dt>Implementation experience</dt>
          <dd>TBD</dd>
          <dt>Contact</dt>
          <dd>TBD</dd>
        </dl>
      </section>
   -->
    </section>
    <section anchor="Security" numbered="true" toc="default">
      <name>Security Considerations</name>
      <t>In this section we discuss the security properties of WESPv2: TBD</t>
      <!--
      <t>
      Some text ...
   </t>
   -->
    </section>
    <section anchor="Acknowledgements" numbered="true" toc="default">
      <name>Acknowledgments</name>
      <t>TBD</t>
    </section>
  </middle>
  <back>
    <references>
      <name>Normative References</name>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3948.xml"/>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4303.xml"/>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5840.xml"/>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7296.xml"/>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2992.xml"/>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8200.xml"/>
      <!--
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4301.xml"/>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.791.xml"/>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8200.xml"/>
      -->
    </references>
    <references>
      <name>Informative References</name>
      <!--
      <xi:include href="https://bib.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-ipsecme-multi-sa-performance.xml"/>
      -->
      <xi:include href="https://bib.ietf.org/public/rfc/bibxml3/reference.I-D.mrossberg-ipsecme-multiple-sequence-counters.xml"/>
      <xi:include href="https://bib.ietf.org/public/rfc/bibxml3/reference.I-D.ponchon-ipsecme-anti-replay-subspaces.xml"/>
      <xi:include href="https://bib.ietf.org/public/rfc/bibxml3/reference.I-D.he-ipsecme-vpn-shared-ipsecsa.xml"/>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6982.xml"/>
      <xi:include href="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7942.xml"/>
      <reference anchor="PSP"
      target="https://github.com/google/psp/blob/main/doc/PSP_Arch_Spec.pdf"
      quoteTitle="true">
        <front>
          <title>PSP Architecture Specification</title>
          <author>
            <organization showOnFrontPage="true">Google</organization>
          </author>
        </front>
      </reference>
      <!--
      <reference anchor="NVIDIA-PSP"
      target="https://docs.nvidia.com/doca/sdk/nvidia+doca+psp+gateway+application+guide/index.html"
      quoteTitle="true">
        <front>
          <title>NVIDIA DOCA PSP Gateway Application Guide</title>
          <author>
            <organization showOnFrontPage="true">NVIDIA</organization>
          </author>
        </front>
      </reference>
      -->
      <!--
      <reference anchor="Google-PSPS-Support" target="https://cloud.google.com/blog/products/identity-security/announcing-psp-security-protocol-is-now-open-source" quoteTitle="true">
        <front>
          <title>NVIDIA DOCA PSP Gateway Application Guide</title>
          <author>
                                                <organization showOnFrontPage="true">NVIDIA</organization>
          </author>
                    </front>
      </reference>
                        -->
    </references>
    <section anchor="app-additional" numbered="true" toc="default">
      <name>Additional Stuff</name>
      <t>TBD</t>
    </section>
  </back>
</rfc>
