<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt"?>
<rfc category="std"
    consensus="true"
     docName="draft-klassert-ipsecme-eesp-00"
     ipr="trust200902"
    sortRefs="true"
    submissionType="IETF"
    symRefs="true"
    tocDepth="3"
    tocInclude="true"
    version="3">
  <front>
    <title abbrev="EESP">Enhanced Encapsulating Security Payload (EESP)</title>
<author initials='S.' surname='Klassert' fullname='Steffen Klassert'><organization abbrev="secunet">secunet Security Networks AG</organization>
<address><email>steffen.klassert@secunet.com</email></address>
</author>
<author initials='C.' surname='Hopps' fullname='Christian Hopps'><organization>LabN Consulting, L.L.C.</organization>
<address><email>chopps@chopps.org</email></address>
</author>
<author initials='A.' surname='Antony' fullname='Antony Antony'><organization abbrev="secunet">secunet Security Networks AG</organization>
<address><email>antony.antony@secunet.com</email></address>
</author>
  <date/>
    <area>SEC</area>
    <workgroup>IPSECME Working Group</workgroup>
<keyword>EESP</keyword>
<keyword>IKEv2</keyword>
<abstract><t>This document describes the Enhanced Encapsulating Security Payload
(EESP) protocol, which builds on the Encapsulating Security Payload
(ESP) <xref target="RFC4303"/>. It is designed to overcome limitations of the ESP
protocol to expose inner flow information to the network in a
transparent way. To do so, it adapts IPv6 Extension header options to
EESP where flow identifiers can be stored.</t></abstract>
  </front>
  <middle>

<section title="Introduction">
<t>Due to the absence of a version number in the ESP protocol, in the
packet header, ESP can't be updated in a transparent way. Any updates
to ESP must be negotiated by IKEv2 and for that, indiscernible to
intermediate devices such as routers and firewalls. In the recent
past, several attempts were taken to introduce a Flow Identifier for
certain use-cases. Examples are
<xref target="I-D.ponchon-ipsecme-anti-replay-subspaces"/> and
<xref target="I-D.he-ipsecme-vpn-shared-ipsecsa"/>. Such a Flow Identifier could
also be used to perform ECMP based on the inner flows at intermediate
devices or endpoints.  dditionally to that, there exists a
specification of the <xref target="PSP"/> protocol that has the need of a Flow
Identifier, called Network Identifier (VNI) there. PSP also defines a
Crypto Offset to expose parts of the headers of the inner packet.
EESP provides a solution for all the aforementioned use-cases.</t>

<t>This document defines Options for the PSP usecase. Future documents
can define the meaning of additional Options for their particular
use-case. With this, all existing and potential new use-cases for
Flow Identifiers can be covered. For instance it can be used for the
case of <xref target="I-D.ponchon-ipsecme-anti-replay-subspaces"/> or
<xref target="I-D.he-ipsecme-vpn-shared-ipsecsa"/> etc., or combinations thereof.
EESP does not have a trailer as ESP had, instead the Next Header an
Pad Length values are moved to the EESP header. Additionally, an
Optimized EESP header is defined which eliminates these 2 values when
using simple IPv4 or IPv6 tunnel mode. EESP also does not define TFC
padding, IP-TFS SHOULD be used instead. A detailed discussion about
the problems of the ESP protocol can be found in
<xref target="I-D.mrossberg-ipsecme-multiple-sequence-counters"/>.</t>

<t>EESP follows the Security Architecture for the Internet Protocol
<xref target="RFC4301"/> and uses ESP as of <xref target="RFC4303"/> as reference. That means
this document is seen as an modern version of ESP (with new protocol
number), it follows the design principles of ESP. Protocol parts that
are not mentioned here, MUST be handled exactly the way as specified
in <xref target="RFC4303"/>. EESP neither updates nor obsoletes <xref target="RFC4303"/>.</t>

<t>Though this document specifies IKEv2 as a negotiation protocol, EESP
may use other protocols for negotiation and key derivation. The
packet specification is portable to other key protocol use cases,
such as <xref target="PSP"/>, and offers versioning at the packet level.</t>


<section title="Requirements Language">
<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
document are to be interpreted as described in <xref target="RFC2119"/>.</t>

</section>


<section title="Terminology">
<t>This document uses the following terms defined in IKEv2 <xref target="RFC7296"/>:
Child SA, CREATE_CHILD_SA, IKE_AUTH exchange, USE_TRANSPORT_MODE</t>

<t>This document uses the following terms defined in <xref target="PSP"/>: PSP (a
recursive acronym for PSP Security Protocol), Network Identifier
(VNI), Crypt Offset.</t>

<t>This document uses the following terms defined in <xref target="RFC5840"/>:
Wrapped Encapsulating Security Payload (WESP), USE_WESP_MODE.</t>

<t>This document uses the following terms defined in <xref target="RFC2992"/>:
Equal-cost multi-path (ECMP)</t>

<t>This document uses the following terms defined in <xref target="RFC4303"/>:
Encapsulating Security Payload (ESP).</t>

<t>This document uses the following terms defined in
<xref target="I-D.mrossberg-ipsecme-multiple-sequence-counters"/>: Sub-Child SA.</t>

</section>

</section>


<section title="Protocol Definition">
<t>In this section we define the exact protocol formats and operations.
This section is normative.</t>


<section title="EESP packet format">
<t>The (outer) protocol header (IPv4, IPv6, or Extension) that
immediately precedes the ESP header SHALL contain the value TBD in
its Protocol (IPv4) or Next Header (IPv6, Extension) field (see IANA
web page at <eref target="http://www.iana.org/assignments/protocol-numbers"/>).
<xref target="eesp-top-level-packet-format"/> illustrates the top-level format of
an EESP packet. The EESP header is split into multiple parts.</t>

<figure anchor="eesp-top-level-packet-format">
<name>Top-Level Format of an EESP Packet</name>
<sourcecode><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
~                      Base Header                              ~
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
~                      Options (variable)                       ~
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
~                     Host Header (variable)                    ~
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       Payload Info Header                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      Payload Data (variable)                  |
~                                                               ~
|               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|               |          Padding (0-255 bytes)                |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
~              Integrity Check Value-ICV (variable)             ~
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></sourcecode></figure>

<t>The packet starts with a Base Header that is used by protocol parsing
engines of middleboxes such as routers or firewalls and the IPsec end host.
The Base Header consists of a 8-bytes that are always present and an
optional part directly following this field. The base header
essentially defines the total length of the EESP header and the
length of potential present options as well as the EESP version
number. The optional part of the Base Header defines Options to store
additional information, like integrity protected flow identifiers
that can be used for flow classification.</t>

<t>Base Header consists of a 6-byte, two bytes Session ID and 4 bytes
Security Parameters Index (SPI).</t>

<t>The Host Header follows the Base Header and, possible Options.
It is used to route the packet to the correct Crypto context and for replay
protection.</t>

<t>Unlike ESP, EESP does not have a trailer. Instead, these values have
moved to a Payload Info Header directly following the Host Header.
Additionally, when IPv4 or IPv6 tunnel mode is used an the Payload
Info Header MAY be elided. In this tunnel mode the inner packet will
always start with an IPv4 or IPv6 header. IPv4 or IPv6 packets always
start with a Version field at the first nibble. So it is possible to
identify IPv4 and IPv6 by reading the first nibble of the inner
packet. and there is no need for a Next Header field. Additionally,
IPv4 and IPv6 also have a field describing the overall size of the
inner packet, so a pad length fields is also not needed for tunnel
mode as it can be derived.</t>

<t>The Payload Data follows these header fields, and has substructure
that depends on the choice of encryption algorithm and mode.
Following the Payload Data is variable cipher block padding and the
optional Integrity Check Value (ICV) field that completes the packet.</t>

<t><xref target="eesp-optimized-packet-format"/> illustrates the resulting packet
format for IPv4 or IPv6 Tunnel Mode and <xref target="eesp-full-packet-format"/>
in all other modes of operation.</t>

<figure anchor="eesp-optimized-packet-format">
<name>Optimized EESP packet format</name>
<sourcecode><![CDATA[

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|1|  Version    |    OptLen     |            Session ID +       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               |
|                              SPI                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
~                             Options                           ~
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Sequence Number (optional)                 |
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          IV* (optional)                       |
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               ~
~                     IPv4/IPv6 Header                          ~
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                   L4 Payload Data (variable)                  |
~                                                               ~
|               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|               |          Padding (0-255 bytes)                |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
~              Integrity Check Value-ICV (variable)             ~
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></sourcecode></figure>

<figure anchor="eesp-full-packet-format">
<name>Full EESP packet format</name>
<sourcecode><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|0|  Version    |    OptLen     |            Session ID +       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               |
|                              SPI                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
~                             Options                           ~
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Sequence Number (optional)                 |
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          IV* (optional)                       |
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  0x0  |        Reserved       | Next Header   | Pad Length    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                   L4 Payload Data (variable)                  |
~                                                               ~
|               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|               |          Padding (0-255 bytes)                |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
~              Integrity Check Value-ICV (variable)             ~
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></sourcecode></figure>

<t>[*] If included, cryptographic synchronization data, e.g., an
Initialization Vector (IV), usually is not encrypted per se, although
it often is referred to as being part of the ciphertext. Unlike ESP,
the IV is not considered to be a part of the payload data in EESP.</t>

<t>If a combined algorithm mode is employed, the explicit ICV shown in
<xref target="eesp-packet-separate-algos"/> may be omitted.  Because algorithms,
modes and options are fixed when an SA is established, the detailed
format of ESP packets for a given SA (including the Payload Data
substructure) is fixed, for all traffic on the SA.</t>

<t>The tables below refer to the fields in the preceding figures and
illustrate how several categories of algorithmic options, each with a
different processing model, affect the fields noted above.  The
processing details are described in later sections.</t>

<table anchor="eesp-packet-separate-algos">
<name>Separate Encryption and Integrity Algorithms</name>
<thead><tr><th>Field</th><th align="center"># of bytes</th><th align="center">Requ'd [1]</th><th align="center">Encrypt Covers</th><th align="center">Integ Covers</th><th align="center">Tx'd</th></tr>
</thead>
<tbody><tr><td>Base Header(+SPI)</td><td align="center">8</td><td align="center">M</td><td align="center">&#xa0;</td><td align="center">Y</td><td align="center">plain</td></tr>
<tr><td>Options</td><td align="center">variable</td><td align="center">O</td><td align="center">&#xa0;</td><td align="center">Y</td><td align="center">plain</td></tr>
<tr><td>Seq Number</td><td align="center">8</td><td align="center">O</td><td align="center">&#xa0;</td><td align="center">Y</td><td align="center">plain</td></tr>
<tr><td>IV</td><td align="center">variable</td><td align="center">O</td><td align="center">&#xa0;</td><td align="center">Y</td><td align="center">plain</td></tr>
<tr><td>Payload Info Header   [5]</td><td align="center">4</td><td align="center">O</td><td align="center">Y</td><td align="center">Y</td><td align="center">cipher [3]</td></tr>
<tr><td>IP datagram [2]</td><td align="center">variable</td><td align="center">M or D</td><td align="center">Y</td><td align="center">Y</td><td align="center">cipher [3]</td></tr>
<tr><td>Padding</td><td align="center">0-255</td><td align="center">M</td><td align="center">Y</td><td align="center">Y</td><td align="center">cipher [3]</td></tr>
<tr><td>ICV Padding</td><td align="center">variable</td><td align="center">if need</td><td align="center">&#xa0;</td><td align="center">Y</td><td align="center">not xmtd</td></tr>
<tr><td>ICV</td><td align="center">variable</td><td align="center">M [4]</td><td align="center">&#xa0;</td><td align="center">&#xa0;</td><td align="center">plain</td></tr>
</tbody>
</table>

<ul spacing="compact">
<li><t>[1] M = mandatory; O = optional; D = dummy</t></li>
<li><t>[2] If tunnel mode -&gt; IP datagram. If beet mode -&gt; IP datagram. If
transport mode -&gt; next header and data</t></li>
<li><t>[3] ciphertext if encryption has been selected</t></li>
<li><t>[4] Mandatory if a separate integrity algorithm is used</t></li>
<li><t>[5] Not present in Optimized Header otherwise mandatory</t></li>
</ul>

<t>The following subsections describe the fields in the header format.
"Optional" means that the field is omitted if the option is not
selected, i.e., it is present in neither the packet as transmitted
nor as formatted for computation of an ICV. Whether or not an option
is selected is determined as part of Security Association (SA)
establishment. Thus, the format of EESP packets for a given SA is
fixed, for the duration of the SA. In contrast, "mandatory" fields
are always present in the EESP packet format, for all SAs.</t>

</section>


<section title="Base Header">
<section title="Fixed Base Header">
<ul>
<li><t>Version - 7 bits: MUST be sent to zero and checked by the receiver.</t></li>
</ul>
<t>If the version is different than an expected version number (e.g.,
  negotiated via the control channel), then the packet MUST be
  dropped by the receiver. Future modifications to the EESP header
  require a new version number. In particular, the version of EESP
  defined in this document does not allow for any extensions.
  Intermediate nodes dealing with unknown versions are not
  necessarily able to parse the packet correctly. Intermediate
  treatment of such packets is policy dependent (e.g., it may dictate
  dropping such packets).</t>
<ul>
<li><t>OptLen - 8 bits: Overall length of the Options following the fixed
Baseheader in bytes. For the intermediate routers to parse options.</t></li>
<li><t>Session ID - 16 bit: The Session ID covers additional information
that might be needed to route the packet to the correct inline
crypto context. For instance, if a KDF is used do stateless key
derivation, the crypto algorithm ID could be encoded there. The
meaning of that field is opaque and MAY be negotiated by IKEv2.
This combined with following 32bits Security Parameter Index (SPI) is the</t></li>
</ul>

</section>


<section title="Base Header Options">
<t>EESP options carry a variable number of "options" that are
type-length- value (TLV) encoded in the similar format as done in
<xref target="RFC8200"/> Section 4.2 for IPv6 extension headers. This document
defines three different option classes, Padding Options, Flow
Identifier Options and Private Options.</t>

<t>Padding Options MUST be used to align the start of the next header to
the natural alignment of the protocol, i.e. 4 byte for IPv4 and 8
byte for IPv6. Other padding, like padding for cipher text alignment,
is out of the scope of this document. Future documents can define
this by using the existing padding options. Additional padding MUST
be negotiated by IKEv2 or any other suitable protocol.</t>

<t>Flow Identifier Options MUST carry characteristic information of the
inner flow, i.e. MUST NOT change on per packet basis. It MUST be
negotiated by IKEv2 or any other suitable protocol.  The detailed
specification of Flow Identifiers MUST be provided in subsequent
documents. These Options are opaque to intermediate devices; however,
intermediate routers MAY use it for identifying flows for ECMP or
similar purposes. e.g. Sub-Child SAs, in
<xref target="I-D.mrossberg-ipsecme-multiple-sequence-counters"/>could be encoded
here. Flow Identifiers MUST have the format of Options as defind in
<xref target="Adapt-Options"/>.</t>

<t>Private Options comming from a reserved Option Type Range and can be
used for any purposes that are out of scope for standardization. For
example it can be used to encode hardware specific information, such
as used encryption/authentication algorithms as done in <xref target="PSP"/>.</t>

<t>The only EESP Option Types defined in this document are the Pad1 and
PadN options specified in <xref target="Adapt-Options"/>.</t>

<section title="Adapting IPv6 Extension header options" anchor="Adapt-Options">
<t>EESP extension header Options are adapted from IPv6 extension header
Options as defined in Section 4.2 of <xref target="RFC8200"/>, with the following
modifications:</t>


<ul>
<li><t>References to the IPv6 header are removed.</t></li>
<li><t>The two highest-order bits of the Option Type MUST be set to 00, if
the Option Type comes from the private range.</t></li>
<li><t>The third-highest-order bit of the Option Type MUST be set to 0.</t></li>
<li><t>References to the Hop-by-Hop Options header and the Destination
Options header are removed.</t></li>
</ul>

</section>

<section title="EESP Extension header options" anchor="EESP-Options">
<t>EESP Options carry a variable number of type-length-value (TLV)
encoded "options", of the following format:</t>

<figure>
<name>EESP Header Option Format</name>
<sourcecode><![CDATA[

+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - - -
|  Option Type  |  Opt Data Len |  Option Data
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - - -

]]></sourcecode></figure>

<ul>
<li><t>Option Type: 8-bit identifier of the type of option.</t></li>
<li><t>Opt Data Len: 8-bit unsigned integer.  Length of the Option Data
field of this option, in octets.</t></li>
<li><t>Option Data: Variable-length field. Option-Type-specific data.</t></li>
</ul>

<t>The sequence of options within a header must be processed strictly in
the order they appear in the header; a receiver must not, for
example, scan through the header looking for a particular kind of
option and process that option prior to processing all preceding
ones.</t>

</section>

</section>

<section title="Host Header">
<t>Following the Base Header and Options is the Host Header for e.g.
optional Sequence Number. When persent it is full 64bit sequence number.
EESP only support 64bit sequence numbers, a.k.a ESN and transmits the entire
sequence number on each packet.</t>

</section>

<section title="Sequence Number">
<t>This unsigned 64-bit field contains a counter value that increases by
for each packet sent, i.e., a per-SA packet sequence number. For a
unicast SA or a single-sender multicast SA, the sender MUST increment
this field for every transmitted packet. The sequence number MUST
strictly monotonic increase, sequence numbers MUST not repeat and
MUST not cycle for any given SA. Thus, the sender's counter and the
receiver's counter MUST be reset (by establishing a new SA and thus a
new key) prior to the transmission of the 2^64nd packet on an SA.
Implementations that do replay protection SHOULD increase the
sequence number by one for each send packet. Even if recommended to
increase the sequence number by one, implementatins MAY employ other
methods to increase the sequence number, as long as the
aforementioned requirements are met. Sharing an SA among multiple
senders is permitted, though generally not recommended. EESP
provides no means of synchronizing packet counters among multiple
senders or meaningfully managing a receiver packet counter and window
in the context of multiple senders. Unless any future Option
defining this for a multi-sender SA, the anti-replay features of ESP
are not available.</t>

<t>The field is mandatory and MUST always be present even if the
receiver does not elect to enable the anti-replay service for a
specific SA. Processing of the Sequence Number field is at the
discretion of the receiver, but all ESP implementations MUST be
capable of performing the processing described in Sections 3.3.3 and
3.4.3. Thus, the sender MUST always transmit this field, but the
receiver need not act upon it.</t>

<t>AA Note</t>
<ul>
<li><t><strong>AA Note:</strong> <xref target="RFC4303"/> Section 2.2 stipulate:</t></li>
</ul>
<t>The sender's counter and the receiver's counter are initialized to 0
when an SA is established. (The first packet sent using a given SA
should have a sequence number of 1).</t>

<ul>
<li><t><strong>AA Note:</strong> <xref target="RFC9347"/> Section 2.2.3 While ESP guarantees an</t></li>
</ul>
<t>increasing sequence number with subsequently
sent packets, it does not actually require the sequence numbers to be
generated consecutively (e.g., sending only even-numbered sequence
numbers would be allowed, as long as they are always increasing).
Gaps in the sequence numbers will not work for this document, so the
sequence number stream MUST increase monotonically by 1 for each
subsequent packet.</t>

</section>

<section title="Initialization Vector">
<t>If the algorithm used to encrypt the payload requires cryptographic
synchronization data, e.g., an Initialization Vector (IV), then this
data is carried explicitly in front of the encrypted part of the
packet in the Crypto Header.  Any encryption algorithm that requires
such explicit, per-packet synchronization data MUST indicate the
length, any structure for such data, and the location of this data as
part of an RFC specifying how the algorithm is used with EESP.
(Typically, the IV immediately precedes the ciphertext.  See Table 1)
If such synchronization data is implicit, the algorithm for deriving
the data MUST be part of the algorithm definition RFC.  (If included,
cryptographic synchronization data, e.g., an Initialization Vector
(IV), usually is not encrypted per se (see Table 1), although it
sometimes is referred to as being part of the ciphertext.)</t>

<t>Counter mode algorithms SHOULD encode the 64-bit counter of the
Initialization Vector (IV) on the Sequence number Field.  This option
saves 8 header bytes on each packet.  Whether or not this option is
selected is determined as part of Security Association (SA)
establishment.</t>

</section>

</section>

<section title="Payload Info Header">
<section title="Next Header">
<t>The Next Header is a, 8-bit field that identifies the type of data
contained in the Payload Data field, e.g., a next layer header and
data. The value of this field is chosen from the set of IP Protocol
Numbers defined on the web page of the IANA, e.g., a value of 6
indicates TCP and a value of 17 indicates UDP.</t>

<ul>
<li><t><strong>AA Note:</strong> When there is Crypto Header/PSP and say transport mode would</t></li>
</ul>
<t>there be two " Next Header fields"</t>

</section>

<section title="Pad Length">
<t>The Pad Length field indicates the number of pad bytes immediately
preceding it in the Padding field. The range of valid values is 0 to
255, where a value of zero indicates that no Padding bytes are
present.</t>

</section>

</section>


<section title="Padding (for Encryption)">
<t>TBD</t>

</section>


<section title="Integrity Check Value (ICV)">
<t>Integrity Check Value is handled as in <xref target="RFC4303"/>.</t>

</section>

</section>


<section title="UDP Encapsulation">
<t>TBD</t>

</section>


<section title="Enhanced Encapsulating Security Protocol Processing">
<t>TBD</t>

</section>


<section title="EESP Option Types">
<t>This document defines two padding options to align following headers
to their natural protocol alignment and one option defining the
Pretty Security Protocol (PSP). Future documents can define furter
options. Appendix A of <xref target="RFC8200"/> contains applicable formatting
guidelines for designing new options.</t>


<section title="EESP Flow Identifier Option">
<t>Flow Identifier Options are constructed as described in
<xref target="EESP-Options"/>.</t>

<figure anchor="fid-option">
<name>Flow Identifier Option</name>
<sourcecode><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Option Type  | Option Length |                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               |
|                                                               |
~                    Flow Identifier (FID)                      ~
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></sourcecode></figure>

<ul>
<li><t>Option Type - 8 bits: See <xref target="EESP-Options"/></t></li>
<li><t>Option Length - 8 bits: See <xref target="EESP-Options"/></t></li>
<li><t>FID: Variable length, MUST carry caracteristic infromation of the
inner flow i.e. MUST not change within a gives SA.</t></li>
</ul>

</section>


<section title="EESP Crypt Offset Option">
<t>This option is typically used for within one Datacenter use case
such as <xref target="PSP"/>.</t>

<figure anchor="psp-option">
<name>PSP Option</name>
<sourcecode><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Option Type  | Option Length |NextHeader     |CryptOffset|Flags|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></sourcecode></figure>

<ul>
<li><t>Option Type - 8 bits: See <xref target="EESP-Options"/></t></li>
<li><t>Option Length - 8 bits: See <xref target="EESP-Options"/></t></li>
<li><t>Next Header - 8 bits: MUST be set to 59, <xref target="RFC8200"/> Section 4.7
when CryptOffset is zero, and MUST be set to the Next Header value
of the inner packet. For the use of intermediate routers.</t></li>
<li><t>CryptOffset - 6 bits: The offset from the end of the IV to the start
of the encrypted portion of the packet, measured in 4 octet units.
The resulting value MUST NOT be larger than the size of the inner
packet.  A zero CryptOffset means that the complete packet is
authenticated and encrypted.  A positive CryptOffset means that the
first 'CryptOffset * 4' octets of the inner packet belong to the
AAD but are not encrypted.  In this case the Next Header field MUST
be the same as the Next Header field in the ESP trailer, so that
the Header can be parsed by intermediate devices. (Authors note:
This is to preserve the original WESP use-case and because PSP uses
this too.  In case the Flow Identifier Options can carry enough
information about inner flows, we can remove the cryptoffset.)</t></li>
<li><t>Flags - 2 bits: TBD : Used for inline crypto signlaing such as  s
d bit in PSP specification</t></li>
</ul>

</section>

</section>

<section title="IKEv2 Negotiation">
<t>TBD</t>

</section>

<section title="IANA Considerations">
<section title="IP Protocol Number">
<t>This document requests IANA place a reference to this document to the
Reserved value 0x0 in the IP protocol version number space.</t>

<t>Note: Maybe we don't need this, because we know if this is transport
or tunnel mode...</t>

</section>


<section title="EESP Protocol Number">
<t>This document requests IANA allocate an IP protocol number from
"Protocol Numbers - Assigned Internet Protocol Numbers" registry</t>

<ul>
<li><t>Decimal: TBD</t></li>
<li><t>Keyword: EESP</t></li>
<li><t>Protocol: Enhanced Encapsulating Security Payload</t></li>
<li><t>Reference: This document</t></li>
</ul>

</section>


<section title="EESP Options Registry">
<t>This document requests IANA to create a registry called "EESP_OPTIONS
Type Registry" under a new category named "EESP_OPTIONS Parameters".</t>

<ul>
<li><t>Name: EESP Options Registry</t></li>
<li><t>Description: EESP Base Header Options</t></li>
<li><t>Reference: This document</t></li>
</ul>

<t>The initial content for this registry is as follows:</t>

<figure anchor="iana_requests_reg">
<name>Initial Registry Values</name>
<sourcecode><![CDATA[
Value   EESP Header Options Types          Reference
-----   ------------------------------    ---------------
    1   Crypt Offset                      [this document]
    2   FID                               [this document]
 3-26   Unassigned                        [this document]
27-31   Private                           [this document]
]]></sourcecode></figure>

</section>

</section>

<section title="Implementation Status">
<t>[Note to RFC Editor: Please remove this section and the reference to
<xref target="RFC6982"/>before publication.]</t>

<t>This section records the status of known implementations of the
protocol defined by this specification at the time of posting of this
Internet-Draft, and is based on a proposal described in <xref target="RFC7942"/>.
The description of implementations in this section is intended to
assist the IETF in its decision processes in progressing drafts to
RFCs. Please note that the listing of any individual implementation
here does not imply endorsement by the IETF. Furthermore, no effort
has been spent to verify the information presented here that was
supplied by IETF contributors. This is not intended as, and must not
be construed to be, a catalog of available implementations or their
features. Readers are advised to note that other implementations may
exist.</t>

<t>According to <xref target="RFC7942"/>, "this will allow reviewers and working
groups to assign due consideration to documents that have the benefit
of running code, which may serve as evidence of valuable
experimentation and feedback that have made the implemented protocols
more mature. It is up to the individual working groups to use this
information as they see fit".</t>

<t>Authors are requested to add a note to the RFC Editor at the top of
this section, advising the Editor to remove the entire section before
publication, as well as the reference to <xref target="RFC7942"/>.</t>

</section>


<section title="Security Considerations">
<t>In this section we discuss the security properties of EESP: TBD</t>

</section>

<section title="Acknowledgments">
<t>TBD</t>

</section>

</middle>
<back>
<references title="Normative References">
<reference anchor="RFC2119" target="https://www.rfc-editor.org/info/rfc2119">
  <front>
    <title>Key words for use in RFCs to Indicate Requirement Levels</title>
    <author fullname="S. Bradner" initials="S." surname="Bradner"/>
    <date month="March" year="1997"/>
    <abstract>
      <t>In many standards track documents several words are used to signify the requirements in the specification. These words are often capitalized. This document defines these words as they should be interpreted in IETF documents. This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
    </abstract>
  </front>
  <seriesInfo name="BCP" value="14"/>
  <seriesInfo name="RFC" value="2119"/>
  <seriesInfo name="DOI" value="10.17487/RFC2119"/>
</reference>
<reference anchor="RFC4301" target="https://www.rfc-editor.org/info/rfc4301">
  <front>
    <title>Security Architecture for the Internet Protocol</title>
    <author fullname="S. Kent" initials="S." surname="Kent"/>
    <author fullname="K. Seo" initials="K." surname="Seo"/>
    <date month="December" year="2005"/>
    <abstract>
      <t>This document describes an updated version of the "Security Architecture for IP", which is designed to provide security services for traffic at the IP layer. This document obsoletes RFC 2401 (November 1998). [STANDARDS-TRACK]</t>
    </abstract>
  </front>
  <seriesInfo name="RFC" value="4301"/>
  <seriesInfo name="DOI" value="10.17487/RFC4301"/>
</reference>
<reference anchor="RFC4303" target="https://www.rfc-editor.org/info/rfc4303">
  <front>
    <title>IP Encapsulating Security Payload (ESP)</title>
    <author fullname="S. Kent" initials="S." surname="Kent"/>
    <date month="December" year="2005"/>
    <abstract>
      <t>This document describes an updated version of the Encapsulating Security Payload (ESP) protocol, which is designed to provide a mix of security services in IPv4 and IPv6. ESP is used to provide confidentiality, data origin authentication, connectionless integrity, an anti-replay service (a form of partial sequence integrity), and limited traffic flow confidentiality. This document obsoletes RFC 2406 (November 1998). [STANDARDS-TRACK]</t>
    </abstract>
  </front>
  <seriesInfo name="RFC" value="4303"/>
  <seriesInfo name="DOI" value="10.17487/RFC4303"/>
</reference>
<reference anchor="RFC5840" target="https://www.rfc-editor.org/info/rfc5840">
  <front>
    <title>Wrapped Encapsulating Security Payload (ESP) for Traffic Visibility</title>
    <author fullname="K. Grewal" initials="K." surname="Grewal"/>
    <author fullname="G. Montenegro" initials="G." surname="Montenegro"/>
    <author fullname="M. Bhatia" initials="M." surname="Bhatia"/>
    <date month="April" year="2010"/>
    <abstract>
      <t>This document describes the Wrapped Encapsulating Security Payload (WESP) protocol, which builds on the Encapsulating Security Payload (ESP) RFC 4303 and is designed to allow intermediate devices to (1) ascertain if data confidentiality is being employed within ESP, and if not, (2) inspect the IPsec packets for network monitoring and access control functions. Currently, in the IPsec ESP standard, there is no deterministic way to differentiate between encrypted and unencrypted payloads by simply examining a packet. This poses certain challenges to the intermediate devices that need to deep inspect the packet before making a decision on what should be done with that packet (Inspect and/or Allow/Drop). The mechanism described in this document can be used to easily disambiguate integrity-only ESP from ESP-encrypted packets, without compromising on the security provided by ESP. [STANDARDS-TRACK]</t>
    </abstract>
  </front>
  <seriesInfo name="RFC" value="5840"/>
  <seriesInfo name="DOI" value="10.17487/RFC5840"/>
</reference>
<reference anchor="RFC7296" target="https://www.rfc-editor.org/info/rfc7296">
  <front>
    <title>Internet Key Exchange Protocol Version 2 (IKEv2)</title>
    <author fullname="C. Kaufman" initials="C." surname="Kaufman"/>
    <author fullname="P. Hoffman" initials="P." surname="Hoffman"/>
    <author fullname="Y. Nir" initials="Y." surname="Nir"/>
    <author fullname="P. Eronen" initials="P." surname="Eronen"/>
    <author fullname="T. Kivinen" initials="T." surname="Kivinen"/>
    <date month="October" year="2014"/>
    <abstract>
      <t>This document describes version 2 of the Internet Key Exchange (IKE) protocol. IKE is a component of IPsec used for performing mutual authentication and establishing and maintaining Security Associations (SAs). This document obsoletes RFC 5996, and includes all of the errata for it. It advances IKEv2 to be an Internet Standard.</t>
    </abstract>
  </front>
  <seriesInfo name="STD" value="79"/>
  <seriesInfo name="RFC" value="7296"/>
  <seriesInfo name="DOI" value="10.17487/RFC7296"/>
</reference>
<reference anchor="RFC2992" target="https://www.rfc-editor.org/info/rfc2992">
  <front>
    <title>Analysis of an Equal-Cost Multi-Path Algorithm</title>
    <author fullname="C. Hopps" initials="C." surname="Hopps"/>
    <date month="November" year="2000"/>
    <abstract>
      <t>Equal-cost multi-path (ECMP) is a routing technique for routing packets along multiple paths of equal cost. The forwarding engine identifies paths by next-hop. When forwarding a packet the router must decide which next-hop (path) to use. This document gives an analysis of one method for making that decision. The analysis includes the performance of the algorithm and the disruption caused by changes to the set of next-hops. This memo provides information for the Internet community.</t>
    </abstract>
  </front>
  <seriesInfo name="RFC" value="2992"/>
  <seriesInfo name="DOI" value="10.17487/RFC2992"/>
</reference>
<reference anchor="RFC8200" target="https://www.rfc-editor.org/info/rfc8200">
  <front>
    <title>Internet Protocol, Version 6 (IPv6) Specification</title>
    <author fullname="S. Deering" initials="S." surname="Deering"/>
    <author fullname="R. Hinden" initials="R." surname="Hinden"/>
    <date month="July" year="2017"/>
    <abstract>
      <t>This document specifies version 6 of the Internet Protocol (IPv6). It obsoletes RFC 2460.</t>
    </abstract>
  </front>
  <seriesInfo name="STD" value="86"/>
  <seriesInfo name="RFC" value="8200"/>
  <seriesInfo name="DOI" value="10.17487/RFC8200"/>
</reference>
<reference anchor="RFC9347" target="https://www.rfc-editor.org/info/rfc9347">
  <front>
    <title>Aggregation and Fragmentation Mode for Encapsulating Security Payload (ESP) and Its Use for IP Traffic Flow Security (IP-TFS)</title>
    <author fullname="C. Hopps" initials="C." surname="Hopps"/>
    <date month="January" year="2023"/>
    <abstract>
      <t>This document describes a mechanism for aggregation and fragmentation of IP packets when they are being encapsulated in Encapsulating Security Payload (ESP). This new payload type can be used for various purposes, such as decreasing encapsulation overhead for small IP packets; however, the focus in this document is to enhance IP Traffic Flow Security (IP-TFS) by adding Traffic Flow Confidentiality (TFC) to encrypted IP-encapsulated traffic. TFC is provided by obscuring the size and frequency of IP traffic using a fixed-size, constant-send-rate IPsec tunnel. The solution allows for congestion control, as well as nonconstant send-rate usage.</t>
    </abstract>
  </front>
  <seriesInfo name="RFC" value="9347"/>
  <seriesInfo name="DOI" value="10.17487/RFC9347"/>
</reference>
</references>

<references title="Informative References">
<reference anchor="I-D.mrossberg-ipsecme-multiple-sequence-counters" target="https://datatracker.ietf.org/doc/html/draft-mrossberg-ipsecme-multiple-sequence-counters-02">
  <front>
    <title>Broadening the Scope of Encapsulating Security Payload (ESP) Protocol</title>
    <author fullname="Michael Rossberg" initials="M." surname="Rossberg">
      <organization>Technische Universität Ilmenau</organization>
    </author>
    <author fullname="Steffen Klassert" initials="S." surname="Klassert">
      <organization>secunet Security Networks AG</organization>
    </author>
    <author fullname="Michael Pfeiffer" initials="M." surname="Pfeiffer">
      <organization>Technische Universität Ilmenau</organization>
    </author>
    <date day="15" month="February" year="2024"/>
    <abstract>
      <t>There are certain use cases where the Encapusalating Security Payload (ESP) protocol in its current form cannot reach its maximum potential regarding security, features and performance. Although these scenarios are quite different, the shortcomings could be remedied by three measures: Introducing more fine-grained sub-child-SAs, adapting the ESP header and trailer format, and allowing parts of the transport layer header to be unencrypted. These mechanisms are neither completely interdependent, nor are they entirely orthogonal, as the implementation of one measure does influence the integration of another. Although an independent specification and implementation of these mechanisms is possible, it may be worthwhile to consider a combined solution to avoid a combinatorial explosion of optional features. Therefore, this document does not yet propose a specific change to ESP. Instead, explains the relevant scenarios, details possible modifications of the protocol, collects arguments for (and against) these changes, and discusses their implications.</t>
    </abstract>
  </front>
  <seriesInfo name="Internet-Draft" value="draft-mrossberg-ipsecme-multiple-sequence-counters-02"/>
</reference>
<reference anchor="I-D.ponchon-ipsecme-anti-replay-subspaces" target="https://datatracker.ietf.org/doc/html/draft-ponchon-ipsecme-anti-replay-subspaces-03">
  <front>
    <title>IPsec and IKE anti-replay sequence number subspaces for traffic-engineered paths and multi-core processing</title>
    <author fullname="Paul Ponchon" initials="P." surname="Ponchon">
      <organization>Cisco Meraki</organization>
    </author>
    <author fullname="Mohsin Shaikh" initials="M." surname="Shaikh">
      <organization>Cisco Meraki</organization>
    </author>
    <author fullname="Hadi Dernaika" initials="H." surname="Dernaika">
      <organization>Cisco Meraki</organization>
    </author>
    <author fullname="Pierre Pfister" initials="P." surname="Pfister">
      <organization>Cisco Meraki</organization>
    </author>
    <author fullname="Guillaume Solignac" initials="G." surname="Solignac">
      <organization>Cisco Meraki</organization>
    </author>
    <date day="23" month="October" year="2023"/>
    <abstract>
      <t>This document discusses the challenges of running IPsec with anti- replay in multi-core environments where packets may be re-ordered (e.g., when sent over multiple IP paths, traffic-engineered paths and/or using different QoS classes). A new solution based on splitting the anti-replay sequence number space into multiple different sequencing subspaces is proposed. Since this solution requires support on both parties, an IKE extension is proposed in order to negotiate the use of the anti-replay sequence number subspaces.</t>
    </abstract>
  </front>
  <seriesInfo name="Internet-Draft" value="draft-ponchon-ipsecme-anti-replay-subspaces-03"/>
</reference>
<reference anchor="I-D.he-ipsecme-vpn-shared-ipsecsa" target="https://datatracker.ietf.org/doc/html/draft-he-ipsecme-vpn-shared-ipsecsa-01">
  <front>
    <title>Shared Use of IPsec Tunnel in a Multi-VPN Environment</title>
    <author fullname="Qi He" initials="Q." surname="He">
      <organization>Huawei Technologies</organization>
    </author>
    <author fullname="Wei Pan" initials="W." surname="Pan">
      <organization>Huawei Technologies</organization>
    </author>
    <author fullname="Xiaolan Chen" initials="X." surname="Chen">
      <organization>Huawei Technologies</organization>
    </author>
    <author fullname="Beijing Ding" initials="B." surname="Ding">
      <organization>Huawei Technologies</organization>
    </author>
    <date day="8" month="July" year="2024"/>
    <abstract>
      <t>In a multi-VPN environment, currently, different IPsec tunnels (i.e., different IKE SAs and Child SAs) have to be created to differentiate and protect the traffic of each VPN between the device and its peer. When the number of neighbors of a device and the number of VPNs increases, the number of IPsec tunnels also increases considerably. This results in the need for a large number of SAs, which exceeds the device's capacity. This document proposes a method for different VPNs to share the use of a single IPsec tunnel, which can greatly reduce the number of SAs required in a multi-VPN scenario.</t>
    </abstract>
  </front>
  <seriesInfo name="Internet-Draft" value="draft-he-ipsecme-vpn-shared-ipsecsa-01"/>
</reference>
<reference anchor="RFC6982" target="https://www.rfc-editor.org/info/rfc6982">
  <front>
    <title>Improving Awareness of Running Code: The Implementation Status Section</title>
    <author fullname="Y. Sheffer" initials="Y." surname="Sheffer"/>
    <author fullname="A. Farrel" initials="A." surname="Farrel"/>
    <date month="July" year="2013"/>
    <abstract>
      <t>This document describes a simple process that allows authors of Internet-Drafts to record the status of known implementations by including an Implementation Status section. This will allow reviewers and working groups to assign due consideration to documents that have the benefit of running code, which may serve as evidence of valuable experimentation and feedback that have made the implemented protocols more mature.</t>
      <t>The process in this document is offered as an experiment. Authors of Internet-Drafts are encouraged to consider using the process for their documents, and working groups are invited to think about applying the process to all of their protocol specifications. The authors of this document intend to collate experiences with this experiment and to report them to the community.</t>
    </abstract>
  </front>
  <seriesInfo name="RFC" value="6982"/>
  <seriesInfo name="DOI" value="10.17487/RFC6982"/>
</reference>
<reference anchor="RFC7942" target="https://www.rfc-editor.org/info/rfc7942">
  <front>
    <title>Improving Awareness of Running Code: The Implementation Status Section</title>
    <author fullname="Y. Sheffer" initials="Y." surname="Sheffer"/>
    <author fullname="A. Farrel" initials="A." surname="Farrel"/>
    <date month="July" year="2016"/>
    <abstract>
      <t>This document describes a simple process that allows authors of Internet-Drafts to record the status of known implementations by including an Implementation Status section. This will allow reviewers and working groups to assign due consideration to documents that have the benefit of running code, which may serve as evidence of valuable experimentation and feedback that have made the implemented protocols more mature.</t>
      <t>This process is not mandatory. Authors of Internet-Drafts are encouraged to consider using the process for their documents, and working groups are invited to think about applying the process to all of their protocol specifications. This document obsoletes RFC 6982, advancing it to a Best Current Practice.</t>
    </abstract>
  </front>
  <seriesInfo name="BCP" value="205"/>
  <seriesInfo name="RFC" value="7942"/>
  <seriesInfo name="DOI" value="10.17487/RFC7942"/>
</reference>
<reference anchor="PSP" target='https://github.com/google/psp/blob/main/doc/PSP_Arch_Spec.pdf'>
<front>
<title>PSP Architecture Specification</title>
<author><organization>Google</organization></author>
<date/>
</front>
</reference>
</references>


<section title="Additional Stuff">
<t>TBD</t>

</section>
  </back>
</rfc>
